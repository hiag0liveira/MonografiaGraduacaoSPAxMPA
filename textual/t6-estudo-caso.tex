\chapter{Estudo de Caso }
% : Requisitos, OrganizaÃ§Ã£o, MÃ©todos, Design, ImplementaÃ§Ã£o e Testes
\label{cap:estudo_caso}
Este capÃ­tulo apresenta o contexto, os requisitos, a organizaÃ§Ã£o, os mÃ©todos, o design, a implementaÃ§Ã£o e os testes realizados no desenvolvimento do estudo de caso em uma plataforma de notÃ­cias sobre tecnologia chamada WallTech.


\section{Contexto}
\label{section:contexto}

Este estudo de caso parte do cenÃ¡rio de uma empresa fictÃ­cia do setor de notÃ­cias sobre tecnologia, cujo objetivo Ã© fornecer conteÃºdos atualizados e relevantes sobre inovaÃ§Ãµes e tendÃªncias do mercado. O pÃºblico-alvo inclui entusiastas de tecnologia, profissionais da Ã¡rea e usuÃ¡rios que desejam acompanhar as novidades do setor em diferentes dispositivos, graÃ§as a uma interface responsiva.

A Figura \ref{fig:wireframe-walltech} apresenta o \textit{wireframe} da plataforma \textbf{WallTech}, gerado com o auxÃ­lio da ferramenta \textbf{V0.dev}, que utiliza inteligÃªncia artificial para criar protÃ³tipos de interfaces a partir de descriÃ§Ãµes textuais. Esse modelo visual orienta a organizaÃ§Ã£o dos elementos na interface antes da implementaÃ§Ã£o das versÃµes em \acrshort{csr} e \acrshort{ssr}.

\begin{figure}[H]
  \centering
  \caption{Wireframe da plataforma WallTech}
  \includegraphics[width=0.7\textwidth]{media/wall_tech_wireframe.png}
  \legend{Fonte: os autores.}
  \label{fig:wireframe-walltech}
\end{figure}

Para analisar o impacto de diferentes abordagens de renderizaÃ§Ã£o web, foram desenvolvidos dois protÃ³tipos independentes da plataforma \textbf{WallTech}. O primeiro segue a abordagem de \acrfull{csr}, estruturado como uma \acrfull{spa} utilizando a biblioteca \textit{React}. O segundo utiliza \acrfull{ssr}, implementado como uma \acrfull{mpa} com o framework \textit{Next.js}.

A Figura \ref{fig:caso-uso-walltech} apresenta o diagrama de caso de uso da plataforma, destacando as principais funcionalidades acessÃ­veis a usuÃ¡rios anÃ´nimos, como visualizar notÃ­cias recentes, acessar detalhes e realizar buscas por palavras-chave.

\begin{figure}[H]
  \centering
  \caption{Diagrama de caso de uso da plataforma WallTech}
  \includegraphics[width=0.7\textwidth]{media/wall_tech_use_case.png}
  \legend{Fonte: os autores.}
  \label{fig:caso-uso-walltech}
\end{figure}


\section{Processo de Desenvolvimento}
\label{section:processo-desenvolvimento}
O processo de desenvolvimento utilizado para construir a plataforma WallTech segue a metodologia Ã¡gil \english{Kanban}. Essa metodologia de desenvolvimento Ã¡gil Ã© baseada em um quadro de tarefas, no qual cada tarefa Ã© representada por um cartÃ£o \cite{gomes2014kanban}. O quadro Kanban Ã© dividido em colunas que representam o estado atual de cada tarefa. As colunas mais comuns sÃ£o: \english{To Do}, \english{In Progress} e \english{Done}, e o quadro Ã© atualizado conforme as tarefas sÃ£o realizadas. AlÃ©m dessas colunas, o processo foi adaptado para incluir colunas adicionais como \english{Docs} e \english{Test}, permitindo que a documentaÃ§Ã£o e os testes fossem gerenciados de forma organizada e eficiente durante o desenvolvimento.

A Figura \ref{fig:kanban-walltech} apresenta um exemplo do quadro Kanban utilizado no \english{GitHub Projects}, mostrando a organizaÃ§Ã£o das tarefas e o progresso do desenvolvimento da plataforma WallTech. O quadro reflete a estrutura de colunas adaptada, proporcionando uma visÃ£o clara do fluxo de trabalho da equipe, o que facilita o acompanhamento das tarefas em diferentes estÃ¡gios.

ApÃ³s a definiÃ§Ã£o das funcionalidades principais do sistema, as tarefas foram inicialmente documentadas como \english{user stories}. As \english{user stories} sÃ£o descriÃ§Ãµes simples e compreensÃ­veis das funcionalidades a serem implementadas, permitindo uma comunicaÃ§Ã£o clara entre a equipe de desenvolvimento e as partes interessadas. Cada \english{user story} Ã© associada a um conjunto de requisitos especÃ­ficos e uma definiÃ§Ã£o de pronto, facilitando a compreensÃ£o do que precisa ser desenvolvido.

A partir dessas \english{user stories}, as \english{issues} foram criadas no \english{GitHub Projects}. Cada \english{issue} representa uma tarefa especÃ­fica que deve ser realizada, baseada nas \english{user stories}. No \english{GitHub Projects}, essas \english{issues} sÃ£o organizadas nas colunas do quadro Kanban, permitindo que a equipe visualize o progresso de cada tarefa e as mova conforme o andamento do trabalho.

A Figura \ref{fig:kanban-userstories} mostra um exemplo de cartÃ£o \english{issue} no \english{GitHub Projects}, ilustrando como as \english{user stories} sÃ£o transformadas em tarefas e organizadas dentro do quadro Kanban. Cada \english{issue} possui detalhes sobre a tarefa, como descriÃ§Ãµes, prioridade e prazo, facilitando o gerenciamento e a execuÃ§Ã£o das atividades no time de desenvolvimento.

\begin{figure}[H]
  \centering
  \caption{Exemplo de quadro Kanban no \english{GitHub Projects}}
  \includegraphics[width=1.0\textwidth]{media/wall_tech_kanban.png}
  \legend{Fonte: os autores.}
  \label{fig:kanban-walltech}
\end{figure}

\begin{figure}[H]
  \centering
  \caption{Exemplo de cartÃ£o \english{issue} no \english{GitHub Projects}}
  \includegraphics[width=0.7\textwidth]{media/wall_tech_epic.png}
  \legend{Fonte: os autores.}
  \label{fig:kanban-userstories}
\end{figure}




\subsection{Planejamento Funcional: Ã‰pico e HistÃ³rias de UsuÃ¡rio}

Para guiar o desenvolvimento da plataforma \textbf{WallTech}, foi adotada uma abordagem baseada em prÃ¡ticas Ã¡geis, especialmente no uso de \textit{Ã©picos} e \textit{histÃ³rias de usuÃ¡rio}. Essa tÃ©cnica visa descrever funcionalidades a partir da perspectiva do usuÃ¡rio, proporcionando clareza sobre o propÃ³sito e os objetivos de cada componente da aplicaÃ§Ã£o.

As histÃ³rias de usuÃ¡rio foram redigidas segundo o modelo dos \textbf{3Ws (Who, What, Why)}, uma tÃ©cnica comum em anÃ¡lise de requisitos que busca responder:
\begin{itemize}
  \item \textbf{Who (Quem):} Quem estÃ¡ solicitando ou interagindo com a funcionalidade?
  \item \textbf{What (O quÃª):} Qual Ã© a aÃ§Ã£o ou funcionalidade desejada?
  \item \textbf{Why (Por quÃª):} Qual Ã© o benefÃ­cio ou valor esperado para o usuÃ¡rio?
\end{itemize}

Esse modelo torna a narrativa mais centrada no usuÃ¡rio e contribui para um entendimento compartilhado entre desenvolvedores, designers e partes interessadas. AlÃ©m disso, as funcionalidades foram agrupadas em \textbf{Ã©picos}, que representam blocos de funcionalidades coesas e de maior escala dentro do sistema.

A seguir, apresenta-se o \textbf{EPIC-01}, responsÃ¡vel por organizar as funcionalidades relacionadas Ã  visualizaÃ§Ã£o pÃºblica de notÃ­cias na plataforma WallTech, seguido de suas respectivas histÃ³rias de usuÃ¡rio.

\subsubsection*{EPIC-01: VisualizaÃ§Ã£o de NotÃ­cias (PÃºblico)}

\begin{itemize}
  \item \textbf{ID do Ã‰pico:} EPIC-01
  \item \textbf{Persona Principal:} Leitor (AnÃ´nimo)
\end{itemize}

\noindent \textbf{DescriÃ§Ã£o:} Este Ã©pico representa a â€œvitrineâ€ da plataforma WallTech, onde visitantes anÃ´nimos podem explorar notÃ­cias de tecnologia de forma rÃ¡pida, atrativa e segmentada por paÃ­s. O fluxo foi pensado para maximizar o engajamento do usuÃ¡rio ao destacar as notÃ­cias mais relevantes e oferecer ferramentas intuitivas de busca e filtragem.

\noindent \textbf{Funcionalidades Principais:}
\begin{itemize}
  \item Barra de pesquisa (por tÃ­tulo, palavra-chave ou categoria);
  \item Destaque para a notÃ­cia mais visitada e outras trÃªs recentemente acessadas;
  \item Listagem das cinco Ãºltimas notÃ­cias;
  \item Filtro por paÃ­s (Brasil ou EUA);
  \item PÃ¡gina de detalhes da notÃ­cia com conteÃºdo completo e relacionadas.
\end{itemize}

\noindent \textbf{Requisitos NÃ£o-Funcionais:}
\begin{itemize}
  \item Interface responsiva em diferentes dispositivos;
  \item OtimizaÃ§Ã£o de desempenho para carregamento rÃ¡pido;
  \item Suporte a SEO nas pÃ¡ginas pÃºblicas (relevante em SSR).
\end{itemize}

\noindent \textbf{CritÃ©rios de Aceite:}
\begin{itemize}
  \item Visitantes conseguem navegar e visualizar notÃ­cias sem necessidade de login;
  \item Ã‰ possÃ­vel realizar pesquisas e aplicar filtros por paÃ­s;
  \item A navegaÃ§Ã£o Ã© responsiva, intuitiva e eficiente;
  \item A pÃ¡gina de detalhes apresenta informaÃ§Ãµes completas da notÃ­cia.
\end{itemize}

\subsubsection*{HU01: VisualizaÃ§Ã£o da Tela Inicial com NotÃ­cias em Destaque}

\begin{itemize}
  \item \textbf{Who:} Visitante anÃ´nimo
  \item \textbf{What:} Ver na pÃ¡gina inicial uma barra de pesquisa, uma notÃ­cia mais visitada em destaque, trÃªs outras recÃ©m acessadas e uma lista com as cinco Ãºltimas notÃ­cias publicadas.
  \item \textbf{Why:} Explorar rapidamente o conteÃºdo mais relevante e recente sobre tecnologia.
\end{itemize}

\noindent \textbf{HistÃ³ria:} \textit{Como um visitante, quero ver na pÃ¡gina inicial uma barra de pesquisa, a notÃ­cia mais visitada em destaque, outras trÃªs recÃ©m visitadas ao lado e as cinco Ãºltimas notÃ­cias abaixo, para que eu possa explorar rapidamente o conteÃºdo mais relevante sobre tecnologia.}

\noindent \textbf{CritÃ©rios de Aceite:}
\begin{itemize}
  \item A pÃ¡gina inicial contÃ©m uma barra de pesquisa funcional;
  \item A notÃ­cia mais visitada aparece em destaque;
  \item Outras trÃªs notÃ­cias aparecem ao lado da principal;
  \item Abaixo, as cinco Ãºltimas notÃ­cias sÃ£o exibidas em ordem cronolÃ³gica;
  \item Interface Ã© responsiva e com bom desempenho.
\end{itemize}

\subsubsection*{HU02: Pesquisar NotÃ­cias por Palavra-chave ou Categoria}

\begin{itemize}
  \item \textbf{Who:} Visitante
  \item \textbf{What:} Utilizar a barra de pesquisa para buscar por tÃ­tulo, palavra-chave ou categoria.
  \item \textbf{Why:} Encontrar conteÃºdos relevantes de forma eficiente.
\end{itemize}

\noindent \textbf{HistÃ³ria:} \textit{Como um visitante, quero pesquisar notÃ­cias por tÃ­tulo, palavra-chave ou categoria, para que eu possa encontrar facilmente conteÃºdos relevantes sem precisar navegar por toda a lista.}

\noindent \textbf{CritÃ©rios de Aceite:}
\begin{itemize}
  \item Campo de texto para busca;
  \item Filtro por categoria;
  \item Resultados relevantes sÃ£o exibidos com base na busca;
  \item A busca pode ser combinada com o filtro por categoria;
  \item Mensagem amigÃ¡vel exibida em caso de nenhum resultado.
\end{itemize}

\subsubsection*{HU03: Filtrar NotÃ­cias por PaÃ­s}

\begin{itemize}
  \item \textbf{Who:} Visitante
  \item \textbf{What:} Filtrar as notÃ­cias por paÃ­s usando um seletor com bandeiras.
  \item \textbf{Why:} Visualizar conteÃºdos especÃ­ficos da localidade desejada.
\end{itemize}

\noindent \textbf{HistÃ³ria:} \textit{Como um visitante, quero filtrar notÃ­cias por paÃ­s (Brasil ou EUA), para que eu possa visualizar apenas conteÃºdos relevantes para minha localidade ou interesse regional.}

\noindent \textbf{CritÃ©rios de Aceite:}
\begin{itemize}
  \item Menu com seleÃ§Ã£o de paÃ­s exibindo bandeira e nome;
  \item Lista de notÃ­cias Ã© atualizada dinamicamente conforme a seleÃ§Ã£o;
  \item O filtro mantÃ©m o estado ao navegar;
  \item Filtro compatÃ­vel com busca por palavra-chave ou categoria.
\end{itemize}

\subsubsection*{HU04: Visualizar Detalhes de uma NotÃ­cia}

\begin{itemize}
  \item \textbf{Who:} Visitante
  \item \textbf{What:} Acessar a pÃ¡gina de detalhes de uma notÃ­cia especÃ­fica.
  \item \textbf{Why:} Ler o conteÃºdo completo e visualizar informaÃ§Ãµes adicionais.
\end{itemize}

\noindent \textbf{HistÃ³ria:} \textit{Como um visitante, quero clicar em uma notÃ­cia para acessar sua pÃ¡gina de detalhes, para que eu possa ler o conteÃºdo completo e visualizar informaÃ§Ãµes relacionadas.}

\noindent \textbf{CritÃ©rios de Aceite:}
\begin{itemize}
  \item Acesso a uma URL Ãºnica da notÃ­cia;
  \item ExibiÃ§Ã£o completa do conteÃºdo (tÃ­tulo, autor, data, imagem, corpo do texto, paÃ­s de origem);
  \item ExibiÃ§Ã£o de atÃ© trÃªs notÃ­cias relacionadas;
  \item PÃ¡gina de erro amigÃ¡vel no caso de URL invÃ¡lida;
  \item BotÃ£o para retornar Ã  lista ou pesquisa anterior.
\end{itemize}









\section{Requisitos}
\label{section:requisitos}

O levantamento e a definiÃ§Ã£o dos requisitos da plataforma \textbf{WallTech} foram guiados pelas necessidades dos usuÃ¡rios e organizados por meio da tÃ©cnica de \textit{histÃ³rias de usuÃ¡rio}, agrupadas em \textit{Ã©picos}. A partir da anÃ¡lise funcional do \textbf{EPIC-01 â€” VisualizaÃ§Ã£o de NotÃ­cias (PÃºblico)}, foram identificadas as principais funcionalidades esperadas para a aplicaÃ§Ã£o, considerando tanto o fluxo de interaÃ§Ã£o do visitante quanto os objetivos de usabilidade, desempenho e escalabilidade.

Os requisitos a seguir foram organizados em duas categorias: \textbf{funcionais}, que representam as funcionalidades diretamente percebidas pelos usuÃ¡rios, e \textbf{nÃ£o funcionais}, que tratam de atributos como desempenho, acessibilidade e responsividade.

\subsection{Requisitos Funcionais}
\label{subsec:requisitos-funcionais}

\begin{itemize}
  \item O sistema deve permitir que visitantes visualizem uma lista de notÃ­cias recentes e em destaque.
  \item O sistema deve disponibilizar uma barra de pesquisa por palavra-chave, tÃ­tulo ou categoria.
  \item O sistema deve permitir a filtragem de notÃ­cias por paÃ­s (ğŸ‡§ğŸ‡· Brasil ou ğŸ‡ºğŸ‡¸ EUA).
  \item O sistema deve possibilitar o acesso aos detalhes completos de uma notÃ­cia selecionada.
  \item O sistema deve armazenar localmente os acessos recentes para melhorar a experiÃªncia do usuÃ¡rio.
  \item O sistema deve apresentar mensagens claras em situaÃ§Ãµes de ausÃªncia de conteÃºdo.
\end{itemize}

\subsection{Requisitos NÃ£o Funcionais}
\label{subsec:requisitos-nao-funcionais}

\begin{itemize}
  \item A interface deve ser responsiva, adaptando-se corretamente a diferentes tamanhos de tela.
  \item O carregamento das pÃ¡ginas deve ser otimizado, proporcionando uma experiÃªncia fluida mesmo em conexÃµes lentas.
  \item O sistema deve estar preparado para indexaÃ§Ã£o por motores de busca (SEO), quando aplicado via Server-Side Rendering.
  \item A navegaÃ§Ã£o deve ser acessÃ­vel, com suporte a teclado e leitores de tela.
  \item A interface deve manter a consistÃªncia visual e funcional entre suas versÃµes SPA e MPA.
\end{itemize}




\section{Design do Sistema}
\label{cap:design}

O design do sistema foi orientado para refletir as diferenÃ§as estruturais entre as abordagens \acrshort{spa} e \acrshort{mpa}, levando em consideraÃ§Ã£o os requisitos funcionais da plataforma \textit{WallTech}. Esta vitrine digital exibe notÃ­cias de tecnologia obtidas por meio da \textit{NewsAPI}, com recursos de busca, filtragem e destaque de conteÃºdo segmentado por paÃ­s. NÃ£o hÃ¡ backend prÃ³prio, sendo todas as chamadas feitas diretamente para a API externa, o que simplifica a arquitetura e acentua o papel do frontend na renderizaÃ§Ã£o de conteÃºdo.

Para modelagem arquitetural e comportamental, foram utilizados diagramas da UML, incluindo:
\begin{itemize}
  \item \textbf{Diagrama de Caso de Uso}, para representar as principais funcionalidades acessadas pelos usuÃ¡rios visitantes.
  \item \textbf{Diagrama de SequÃªncia}, a fim de ilustrar o fluxo de interaÃ§Ã£o entre navegador e a \textit{NewsAPI} durante operaÃ§Ãµes como busca e carregamento de notÃ­cias.
  \item \textbf{Diagrama de Componentes}, para representar os mÃ³dulos da aplicaÃ§Ã£o, como a interface, o serviÃ§o de requisiÃ§Ã£o Ã  API, e os componentes de renderizaÃ§Ã£o.
\end{itemize}

As decisÃµes de design foram fundamentadas em boas prÃ¡ticas para renderizaÃ§Ã£o web discutidas por \cite{osmani2025}, bem como nas diretrizes da literatura especializada em arquitetura de frontend, como apresentado pela \cite{atori2024}.

Segundo \cite{osmani2025}, a escolha entre renderizaÃ§Ã£o no cliente ou no servidor deve considerar o contexto da aplicaÃ§Ã£o, os requisitos de desempenho e os objetivos de SEO. JÃ¡ o artigo da \cite{atori2024} destaca que SPAs tendem a oferecer maior fluidez e interatividade, enquanto MPAs sÃ£o mais eficazes em aplicaÃ§Ãµes que dependem de indexaÃ§Ã£o e acessibilidade.

\section{Abordagens de RenderizaÃ§Ã£o e NavegaÃ§Ã£o}
\label{section:abordagens-renderizacao}

Para o estudo comparativo, a plataforma foi desenvolvida em duas arquiteturas distintas de renderizaÃ§Ã£o e navegaÃ§Ã£o: 
\acrfull{ssr} com \acrfull{mpa} e \acrfull{csr} com \acrfull{spa}.  
Cada abordagem foi implementada com tecnologias adequadas ao seu paradigma â€” Next.js para \acrshort{ssr}/\acrshort{mpa} e React para \acrshort{csr}/\acrshort{spa} â€” permitindo observar diferenÃ§as de desempenho, interatividade e otimizaÃ§Ã£o para mecanismos de busca (\acrshort{seo}).

A seguir, cada abordagem Ã© apresentada com seu fluxo tÃ­pico de funcionamento, diagrama de componentes (representando a estrutura modular) e diagrama de sequÃªncia (detalhando as interaÃ§Ãµes passo a passo).

\subsection{SSR/MPA - Fluxo e Arquitetura}
\label{subsec:ssr-mpa}

Na abordagem \acrfull{ssr} com \acrfull{mpa}, cada pÃ¡gina Ã© renderizada no servidor a partir de uma requisiÃ§Ã£o HTTP completa. O HTML final jÃ¡ Ã© entregue com os dados integrados, permitindo que o navegador exiba o conteÃºdo imediatamente, favorecendo o tempo de carregamento inicial e a indexaÃ§Ã£o por \textit{crawlers} \cite{atori2024}.

\begin{itemize}
  \item O \textbf{usuÃ¡rio} acessa o site;
  \item O \textbf{navegador} envia uma requisiÃ§Ã£o \texttt{GET} ao \textbf{servidor Next.js};
  \item O servidor obtÃ©m os dados mais recentes na \textbf{NewsAPI};
  \item O servidor monta a pÃ¡gina HTML jÃ¡ com os dados;
  \item O HTML Ã© enviado ao navegador e exibido;
  \item Cada navegaÃ§Ã£o subsequente gera nova requisiÃ§Ã£o completa ao servidor;
  \item Scripts no cliente utilizam \textbf{LocalStorage} para melhorar a experiÃªncia.
\end{itemize}
  
A Figura \ref{fig:component-diagram-next} ilustra como, nesta arquitetura, o \textbf{navegador} interage diretamente com o \textbf{Servidor Next.js} para cada pÃ¡gina requisitada. O servidor, por sua vez:
\begin{enumerate}
  \item Identifica a rota usando o \textbf{roteamento baseado em arquivos};
  \item Executa a lÃ³gica de busca de dados (\texttt{getServerSideProps});
  \item Faz chamadas Ã  \textbf{NewsAPI} para obter o conteÃºdo;
  \item Renderiza o HTML e o envia ao cliente.
\end{enumerate}

A Figura \ref{fig:sequence-diagram-ssr} detalha a ordem das interaÃ§Ãµes. O usuÃ¡rio inicia a navegaÃ§Ã£o, o servidor processa a requisiÃ§Ã£o, consulta a API externa, renderiza o HTML e envia a resposta pronta para o cliente. O uso de \textit{hydration} ativa a interatividade apÃ³s o carregamento inicial.

\begin{figure}[H]
  \centering
  \caption{Diagrama de sequÃªncia - \acrshort{ssr}/\acrshort{mpa}}
  \includegraphics[width=1\textwidth]{media/wall_tech_sequence_diagram.jpeg}
  \legend{Fonte: os autores.}
  \label{fig:sequence-diagram-ssr}
\end{figure}


A Figura \ref{fig:component-diagram-next} mostra que, nessa arquitetura, o \textbf{servidor Next.js} centraliza o roteamento, a obtenÃ§Ã£o de dados e a renderizaÃ§Ã£o das pÃ¡ginas, entregando ao navegador HTML jÃ¡ prÃ©-renderizado. ApÃ³s o carregamento, scripts ativam a interatividade e permitem o uso do \textbf{LocalStorage}.

\begin{figure}[H]
  \centering
  \caption{Diagrama de Componentes - \acrshort{mpa} (\acrshort{ssr} em Next.js)}
  \includegraphics[width=1\textwidth]{media/component-diagram-next.jpeg}
  \legend{Fonte: os autores.}
  \label{fig:component-diagram-next}
\end{figure}


\subsection{CSR/SPA - Fluxo e Arquitetura}
\label{subsec:csr-spa}

Na abordagem \acrfull{csr} com \acrfull{spa}, o carregamento inicial envia um HTML mÃ­nimo e um pacote JavaScript que contÃ©m toda a lÃ³gica da aplicaÃ§Ã£o. A partir daÃ­, a navegaÃ§Ã£o e renderizaÃ§Ã£o sÃ£o executadas no navegador, sem recarregar a pÃ¡gina.

\begin{itemize}
  \item O \textbf{usuÃ¡rio} acessa o site;
  \item O navegador baixa o \textbf{bundle React} e monta a interface inicial;
  \item O \textbf{gerenciador de estado} solicita dados Ã  \textbf{NewsAPI};
  \item A interface Ã© atualizada dinamicamente com os dados recebidos;
  \item Ao navegar, o \textbf{roteador do React} altera a URL e renderiza novos componentes;
  \item Dados podem ser lidos ou salvos no \textbf{LocalStorage}.
\end{itemize}

A Figura \ref{fig:sequence-diagram-csr} descreve como o navegador processa as interaÃ§Ãµes: primeiro carrega a aplicaÃ§Ã£o, depois solicita dados conforme necessÃ¡rio e atualiza a interface sem recarregar a pÃ¡gina, garantindo uma navegaÃ§Ã£o contÃ­nua.

\begin{figure}[H]
  \centering
  \caption{Diagrama de sequÃªncia - \acrshort{csr}/\acrshort{spa}}
  \includegraphics[width=1\textwidth]{media/wall_tech_detail_sequence_diagram.jpeg}
  \legend{Fonte: os autores.}
  \label{fig:sequence-diagram-csr}
\end{figure}


A Figura \ref{fig:component-diagram-react} mostra que, nessa arquitetura, o navegador concentra toda a lÃ³gica de renderizaÃ§Ã£o. O \textbf{Roteador React} decide quais componentes de pÃ¡gina serÃ£o exibidos, enquanto o \textbf{Gerenciador de Estado} controla o fluxo de dados entre a interface e a \textbf{NewsAPI}.

\begin{figure}[H]
  \centering
  \caption{Diagrama de Componentes - \acrshort{spa} (React)}
  \includegraphics[width=1\textwidth]{media/component-diagram-react.jpeg}
  \legend{Fonte: os autores.}
  \label{fig:component-diagram-react}
\end{figure}



\section{ImplementaÃ§Ã£o}
\label{sec:implementacao}

Esta seÃ§Ã£o descreve o conjunto de tecnologias, bibliotecas e ferramentas que sÃ£o empregadas para a construÃ§Ã£o das duas versÃµes do sistema de prova de conceito, detalhando a fundamentaÃ§Ã£o para a escolha de cada componente do ecossistema de desenvolvimento. O gerenciamento do cÃ³digo-fonte e do ciclo de vida do projeto Ã© realizado com o sistema de controle de versÃ£o \textbf{Git} e a plataforma de hospedagem \textbf{GitHub}, conforme as prÃ¡ticas descritas na SeÃ§Ã£o~\ref{sec:git-github}.

Ambas as implementaÃ§Ãµes consomem dados da mesma fonte externa, a \textbf{News API}, uma \acrshort{api} RESTful que fornece o conteÃºdo jornalÃ­stico para a aplicaÃ§Ã£o, como detalhado na SeÃ§Ã£o~\ref{sec:news-api}. Para garantir a consistÃªncia visual e a qualidade da interface entre as duas arquiteturas, utiliza-se a biblioteca de componentes \textbf{shadcn/ui}, que oferece um conjunto de componentes acessÃ­veis e personalizÃ¡veis, conforme apresentado na SeÃ§Ã£o~\ref{sec:ferramentas-modernas}.

\subsection{ImplementaÃ§Ã£o da AplicaÃ§Ã£o SPA}
\label{ssec:implementacao_spa}

A implementaÃ§Ã£o da \acrfull{spa} Ã© desenvolvida utilizando a biblioteca \textbf{React} na sua versÃ£o 18. O React Ã© uma biblioteca JavaScript declarativa, mantida pela Meta, focada na construÃ§Ã£o de interfaces de usuÃ¡rio a partir de componentes reutilizÃ¡veis. Sua adoÃ§Ã£o neste projeto se dÃ¡ por sua vasta popularidade no mercado e ao seu paradigma de componentizaÃ§Ã£o, que facilita a criaÃ§Ã£o de UIs modulares e de fÃ¡cil manutenÃ§Ã£o \cite{react2025}. A eficiÃªncia da renderizaÃ§Ã£o Ã© otimizada pelo uso de um DOM Virtual, um conceito central da biblioteca que minimiza as manipulaÃ§Ãµes diretas no navegador.

Para a estruturaÃ§Ã£o inicial do projeto e o gerenciamento do ambiente de desenvolvimento, utiliza-se a ferramenta de \textit{build} \textbf{Vite}. O Vite Ã© um ecossistema de desenvolvimento frontend moderno que oferece um servidor de desenvolvimento com recarregamento rÃ¡pido (\textit{Hot Module Replacement}) e um processo de compilaÃ§Ã£o (\textit{build}) otimizado, que resulta em pacotes de produÃ§Ã£o menores e mais eficientes \cite{vite_docs}.

O roteamento no lado do cliente, uma caracterÃ­stica fundamental da arquitetura SPA, implementa-se com a biblioteca \textbf{React Router}. Trata-se da soluÃ§Ã£o padrÃ£o para navegaÃ§Ã£o em aplicaÃ§Ãµes React, que possibilita a criaÃ§Ã£o de uma experiÃªncia de usuÃ¡rio fluida e sem recarregamentos de pÃ¡gina ao manipular a \acrshort{api} de HistÃ³rico do navegador \cite{react_router_docs}. A comunicaÃ§Ã£o com a News API Ã© realizada por meio da \acrshort{api} \texttt{fetch}, nativa dos navegadores modernos.

A \autoref{fig:app-react-csr} mostra a \textbf{pÃ¡gina inicial} da plataforma WallTech na implementaÃ§Ã£o \acrshort{spa} com \acrshort{csr}, em conformidade com o wireframe (\autoref{fig:wireframe-walltech}). Nessa pÃ¡gina, o usuÃ¡rio visualiza a notÃ­cia mais visitada em destaque, trÃªs outras recentemente acessadas ao lado, uma lista com as cinco Ãºltimas notÃ­cias publicadas, alÃ©m de barra de pesquisa e filtro por paÃ­s (Brasil ou EUA).

\begin{figure}[H]
  \centering
  \caption{AplicaÃ§Ã£o SPA com React (\acrshort{csr})}
  \includegraphics[width=0.9\textwidth]{media/app_react_csr.png}
  \legend{Fonte: os autores.}
  \label{fig:app-react-csr}
\end{figure}

\subsection{ImplementaÃ§Ã£o da AplicaÃ§Ã£o MPA}
\label{ssec:implementacao_mpa}

A implementaÃ§Ã£o da \acrfull{mpa}, com foco em \acrfull{ssr}, Ã© desenvolvida com o \emph{framework} \textbf{Next.js} na versÃ£o 14. O Next.js Ã© um meta-framework baseado em React, mantido pela Vercel, que se posiciona como uma soluÃ§Ã£o completa para a construÃ§Ã£o de aplicaÃ§Ãµes web de produÃ§Ã£o. Sua escolha para este estudo de caso justifica-se por ser a principal referÃªncia de mercado para a implementaÃ§Ã£o de \acrshort{ssr} no ecossistema React, oferecendo uma estrutura robusta e opinativa \cite{nextjs2024}.

O \emph{framework} opera sobre um ambiente \textbf{Node.js}, o que permite a execuÃ§Ã£o de cÃ³digo JavaScript no lado do servidor \cite{nodejs2025}. Essa capacidade Ã© a base da renderizaÃ§Ã£o no servidor, onde o Next.js utiliza funÃ§Ãµes especÃ­ficas, como a \texttt{getServerSideProps}, para buscar dados de fontes externas e prÃ©-renderizar o HTML completo de uma pÃ¡gina antes de enviÃ¡-la ao navegador. AlÃ©m disso, o Next.js implementa um sistema de roteamento baseado no sistema de arquivos, onde a estrutura de diretÃ³rios da pasta \texttt{pages} define automaticamente as rotas da aplicaÃ§Ã£o, simplificando a configuraÃ§Ã£o e a manutenÃ§Ã£o do projeto.


A \autoref{fig:app-next-ssr} mostra a \textbf{pÃ¡gina de detalhes} de uma notÃ­cia na plataforma WallTech, na implementaÃ§Ã£o \acrshort{mpa} com \acrshort{ssr}. Ao clicar em uma notÃ­cia na listagem, o usuÃ¡rio Ã© direcionado para esta tela, onde pode visualizar imagem, fonte, tÃ­tulo, metadados (agÃªncia e data/hora) e resumo. TambÃ©m Ã© possÃ­vel acessar a matÃ©ria original pelo botÃ£o â€œLer na fonteâ€ e retornar Ã  pÃ¡gina anterior pelo botÃ£o â€œVoltarâ€.

\begin{figure}[H]
  \centering
  \caption{AplicaÃ§Ã£o MPA com Next.js (\acrshort{ssr})}
  \includegraphics[width=0.9\textwidth]{media/app_next_ssr.png}
  \legend{Fonte: os autores.}
  \label{fig:app-next-ssr}
\end{figure}


\section{Ambiente de ExecuÃ§Ã£o, InstrumentaÃ§Ã£o e Empacotamento}
\label{sec:ambiente-instrumentacao-empacotamento}

Esta seÃ§Ã£o detalha como as duas versÃµes da plataforma \textbf{WallTech} uma \acrshort{mpa} com \acrshort{ssr} (Next.js) e uma \acrshort{spa} com \acrshort{csr} (React+Vite) foram instrumentadas para coleta de \textit{Web Vitals}, empacotadas em contÃªineres \textit{Docker} com \textbf{paridade de recursos} e executadas em ambiente \textbf{local controlado} para assegurar reprodutibilidade do estudo.

\subsection{LimitaÃ§Ãµes de ExecuÃ§Ã£o e DecisÃ£o MetodolÃ³gica}
\label{ssec:limitacoes-execucao}

Durante o desenvolvimento, a \textit{NewsAPI} impÃ´s restriÃ§Ãµes de uso em produÃ§Ã£o (por exemplo, polÃ­ticas de CORS e/ou limitaÃ§Ãµes do plano vigentes no perÃ­odo do estudo), o que impactaria a coleta de dados em ambiente hospedado. Para \textbf{eliminar interferÃªncias externas} e garantir \textbf{controle experimental}, decidiu-se executar ambos os protÃ³tipos \textbf{localmente} em contÃªineres \textit{Docker}, com os \textbf{mesmos limites de CPU e memÃ³ria}, sistema de arquivos \textit{read-only} e partiÃ§Ãµes temporÃ¡rias (\textit{tmpfs}) para reduzir variaÃ§Ãµes de I/O. Assim, a comparaÃ§Ã£o \acrshort{csr}~vs.~\acrshort{ssr} foca no \textit{modelo de renderizaÃ§Ã£o} e nÃ£o em diferenÃ§as de \textit{hosting}.

\subsection{InstrumentaÃ§Ã£o de Web Vitals}
\label{ssec:instrumentacao-webvitals}

Em ambos os protÃ³tipos, a instrumentaÃ§Ã£o Ã© realizada \textbf{no cliente}, e os dados sÃ£o enviados para um \textbf{endpoint interno} exposto pelo prÃ³prio contÃªiner. Utiliza-se \texttt{navigator.sendBeacon} como via principal (por nÃ£o bloquear a navegaÃ§Ã£o) e \texttt{fetch} como \textit{fallback} com \texttt{keepalive}. As mÃ©tricas coletadas sÃ£o os \textit{Core Web Vitals} atuais: \textbf{TTFB}, \textbf{FCP}, \textbf{LCP}, \textbf{CLS} e \textbf{INP}. 

Os registros sÃ£o persistidos em \textbf{NDJSON} (uma linha por mÃ©trica), contendo, dentre outros, os campos:
\texttt{\{id, name, value, rating, navigationType, attribution, entries, ts\}}. A anÃ¡lise estatÃ­stica (p.\,ex., \textbf{p50}/\textbf{p95}) estÃ¡ \textit{deliberadamente breve} aqui e serÃ¡ desenvolvida em capÃ­tulos posteriores.

\subsubsection{SSR/MPA (Next.js).}
Na versÃ£o \acrshort{ssr} (App Router), um \textit{Client Component} global usa \texttt{useReportWebVitals} para escutar e enviar as mÃ©tricas ao endpoint \texttt{/api/vitals}. No servidor, a rota grava o NDJSON em um caminho configurÃ¡vel: por padrÃ£o \texttt{/tmp/webvitals.ndjson} (partiÃ§Ã£o \textit{tmpfs}), ou no caminho definido por \texttt{\$METRICS\_PATH} quando se deseja persistÃªncia via volume.

\begin{lstlisting}[language=TypeScript,caption={Endpoint de mÃ©tricas no SSR/Next.js (visÃ£o de servidor)}]
// src/app/api/vitals/route.ts
import { NextRequest, NextResponse } from "next/server";
import { appendFile } from "node:fs/promises";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

const filePath = process.env.METRICS_PATH ?? "/tmp/webvitals.ndjson";

export async function POST(req: NextRequest) {
  const metric = await req.json();
  const doc = { ...metric, ts: new Date().toISOString() };
  await appendFile(filePath, JSON.stringify(doc) + "\n", "utf8");
  return NextResponse.json({ ok: true });
}
\end{lstlisting}

\begin{lstlisting}[language=TypeScript,caption={Envio de mÃ©tricas no cliente (SSR/Next.js)}]
"use client";
import { useReportWebVitals } from "next/web-vitals";
import { useCallback } from "react";

export default function WebVitals() {
  const report = useCallback((metric: any) => {
    const body = JSON.stringify({
      id: metric.id, name: metric.name, value: metric.value,
      rating: metric.rating, navigationType: metric.navigationType,
      attribution: metric.attribution, entries: metric.entries, ts: Date.now(),
    });

    if (navigator.sendBeacon) {
      navigator.sendBeacon("/api/vitals",
        new Blob([body], { type: "application/json" }));
    } else {
      fetch("/api/vitals", {
        method: "POST", body, keepalive: true,
        headers: { "Content-Type": "application/json" },
      });
    }
  }, []);

  useReportWebVitals(report);
  return null;
}
\end{lstlisting}

\subsubsection{CSR/SPA (React+Vite).}
Na versÃ£o \acrshort{csr}, a coleta usa \texttt{web-vitals/attribution} (para enriquecer \textit{attribution} em \texttt{LCP}/\texttt{CLS}/\texttt{INP}). O envio Ã© feito para \texttt{/api/web-vitals}. Como nÃ£o hÃ¡ servidor \textit{framework} (p.\,ex., Next), a aplicaÃ§Ã£o Ã© servida por um \textbf{processo Node.js} simples (\texttt{server.cjs}) que entrega o \texttt{dist/} e expÃµe o endpoint de mÃ©tricas, gravando no mesmo esquema (\texttt{/tmp} ou \texttt{\$METRICS\_PATH}).

\begin{lstlisting}[language=TypeScript,caption={Envio de mÃ©tricas no cliente (CSR/React+Vite)}]
import { useEffect } from "react";
import { onCLS, onINP, onLCP, onFCP, onTTFB, type MetricWithAttribution } from "web-vitals/attribution";

export default function WebVitals() {
  useEffect(() => {
    const report = (m: MetricWithAttribution) => {
      const body = JSON.stringify({
        id: m.id, name: m.name, value: m.value, rating: m.rating,
        navigationType: m.navigationType, attribution: m.attribution,
        entries: m.entries, ts: Date.now(),
      });

      if (navigator.sendBeacon) {
        navigator.sendBeacon("/api/web-vitals",
          new Blob([body], { type: "application/json" }));
      } else {
        fetch("/api/web-vitals", {
          method: "POST", body, keepalive: true,
          headers: { "Content-Type": "application/json" },
        });
      }
    };

    onCLS(report); onINP(report); onLCP(report); onFCP(report); onTTFB(report);
  }, []);

  return null;
}
\end{lstlisting}

\begin{lstlisting}[language=Java,caption={Servidor estÃ¡tico + endpoint (CSR/React+Vite)}]
// server.cjs - Node HTTP simples (serve dist/ e expÃµe /api/web-vitals)
const http = require("node:http");
const { appendFile, readFile, stat } = require("node:fs/promises");
const { createReadStream } = require("node:fs");
const path = require("node:path");

const PORT = process.env.PORT || 3000;
const DIST = path.join(process.cwd(), "dist");
const METRICS_PATH = process.env.METRICS_PATH || "/tmp/webvitals.ndjson";

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  if (url.pathname === "/api/web-vitals") {
    if (req.method === "POST") {
      const chunks = []; req.on("data", c => chunks.push(c));
      req.on("end", async () => {
        const json = JSON.parse(Buffer.concat(chunks).toString("utf8") || "{}");
        await appendFile(METRICS_PATH, JSON.stringify({ ...json, ts: Date.now() }) + "\n", "utf8");
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ ok: true }));
      });
      return;
    }
    if (req.method === "GET") {
      const data = await readFile(METRICS_PATH, "utf8").catch(() => "");
      res.writeHead(200, { "Content-Type": "application/x-ndjson" });
      res.end(data); return;
    }
    res.writeHead(405).end(); return;
  }

  // estÃ¡tico + fallback SPA
  let p = decodeURIComponent(url.pathname);
  if (p === "/") p = "/index.html";
  const file = path.join(DIST, p);
  try {
    const s = await stat(file); if (s.isDirectory()) throw 0;
    createReadStream(file).pipe(res);
  } catch {
    createReadStream(path.join(DIST, "index.html")).pipe(res);
  }
});
server.listen(PORT);
\end{lstlisting}

\subsection{Empacotamento Docker: SSR/MPA (Next.js)}
\label{ssec:ssr-docker}

Para \acrshort{ssr}, adotou-se o \textbf{modo standalone} do Next.js e \textit{multi-stage build}: (i) instalaÃ§Ã£o de dependÃªncias, (ii) \textit{build} e (iii) \textit{runner} minimalista. O contÃªiner expÃµe a porta \texttt{3000}, roda como usuÃ¡rio \texttt{node} e lÃª variÃ¡veis em tempo de execuÃ§Ã£o (importante para segredos e chaves).

\begin{lstlisting}[language=Dockerfile,caption={Dockerfile da aplicaÃ§Ã£o SSR/MPA (Next.js)}]
# ---------- 1) deps ----------
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --ignore-scripts

FROM node:20-alpine AS builder
WORKDIR /app
ENV NEXT_TELEMETRY_DISABLED=1
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/static ./.next/static

USER node
EXPOSE 3000
CMD ["node", "server.js"]
\end{lstlisting}

\begin{lstlisting}[language=bash,caption={Build e execuÃ§Ã£o do container SSR com limites e volume de mÃ©tricas}]
docker build --no-cache -t next-ssr:prod .

docker run --name next-ssr \
  -p 3001:3000 \
  -e METRICS_PATH=/data/webvitals.ndjson \
  -v "$PWD/metrics:/data:rw" \
  --cpus="1.00" --cpuset-cpus="0" \
  --memory="1g" --memory-swap="1g" \
  --pids-limit=256 \
  --read-only \
  --tmpfs /tmp \
  --tmpfs /app/.next/cache \
  next-ssr:prod
\end{lstlisting}

\subsection{Empacotamento Docker: CSR/SPA (React+Vite)}
\label{ssec:csr-docker}

Para \acrshort{csr}, o \textit{build} Ã© produzido pelo Vite e servido por \texttt{server.cjs}. Diferentemente do \acrshort{ssr}, as variÃ¡veis \texttt{VITE\_*} sÃ£o resolvidas em \textbf{tempo de build}; por isso, a \texttt{.env} Ã© copiada para o estÃ¡gio \textit{builder} (ou alternativamente injetada com \texttt{--build-arg}). Em execuÃ§Ã£o, o caminho do arquivo de mÃ©tricas Ã© definido por \texttt{\$METRICS\_PATH}.

\begin{lstlisting}[language=Dockerfile,caption={Dockerfile da aplicaÃ§Ã£o CSR/SPA (React+Vite)}]
# ---------- 1) deps ----------
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --ignore-scripts

# ---------- 2) build ----------
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
# ğŸ‘‡ garante que o Vite leia suas VITE_* do host
COPY .env ./.env
RUN npm run build

# ---------- 3) runner ----------
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV TZ=UTC
ENV NODE_OPTIONS=--max-old-space-size=512
COPY --from=builder /app/dist ./dist
COPY server.cjs ./server.cjs
USER node
EXPOSE 3000
CMD ["node", "server.cjs"]
\end{lstlisting}

\begin{lstlisting}[language=bash,caption={Build e execuÃ§Ã£o do container CSR com limites e volume de mÃ©tricas}]
docker build -t react-csr:prod .

docker run --name react-csr \
  -p 3002:3000 \
  -e METRICS_PATH=/data/webvitals.ndjson \
  -v "$PWD/metrics-csr:/data:rw" \
  --cpus="1.00" --cpuset-cpus="0" \
  --memory="1g" --memory-swap="1g" \
  --pids-limit=256 --read-only --tmpfs /tmp \
  react-csr:prod
\end{lstlisting}

\subsection{Paridade de Recursos, Observabilidade e Procedimento de Coleta}
\label{ssec:paridade-observabilidade}

Para evitar viÃ©s de ambiente, ambos os contÃªineres executam com \textbf{paridade de recursos}: \texttt{--cpus="1.0"}, \texttt{--cpuset-cpus="0"} (fixaÃ§Ã£o na CPU 0), \texttt{--memory="1g"}, \texttt{--memory-swap="1g"}, \texttt{--pids-limit=256}, \texttt{--read-only} e \texttt{--tmpfs /tmp} (arquivo de mÃ©tricas em memÃ³ria quando nÃ£o houver volume). No \acrshort{ssr}, \texttt{/app/.next/cache} Ã© montado em \texttt{tmpfs} para reduzir variaÃ§Ãµes de disco.

Durante os testes, o uso de recursos foi acompanhado com:
\begin{lstlisting}[language=bash]
docker stats next-ssr
docker stats react-csr
\end{lstlisting}
Esse monitoramento fornece CPU\% e memÃ³ria em tempo real, complementando a coleta de \textit{Web Vitals}. O \textbf{procedimento} adotado foi:
(i) \textit{warm-up} com 2 acessos iniciais Ã  mesma rota para estabilizar caches;
(ii) coleta de 10--15 carregamentos por cenÃ¡rio (janela anÃ´nima);
(iii) persistÃªncia NDJSON por cenÃ¡rio em volumes distintos (por exemplo, \texttt{./metrics} para \acrshort{ssr} e \texttt{./metrics-csr} para \acrshort{csr}).
A \textbf{anÃ¡lise de mÃ©tricas} (estatÃ­sticas descritivas e percentis como p50 e p95) serÃ¡ apresentada em capÃ­tulo especÃ­fico.

\subsection{RepositÃ³rios e Reprodutibilidade}
\label{ssec:repositorios-repro}
O cÃ³digo-fonte, instruÃ§Ãµes de execuÃ§Ã£o e artefatos de instrumentaÃ§Ã£o estÃ£o disponÃ­veis nos repositÃ³rios pÃºblicos da empresa fictÃ­cia \textbf{WallTech}:
\begin{itemize}
  \item \textbf{CSR/SPA (React+Vite)}: \url{https://github.com/WallTechTCC/React-CSR}
  \item \textbf{SSR/MPA (Next.js)}: \url{https://github.com/WallTechTCC/Next-SSR}
\end{itemize}
Esses repositÃ³rios permitem reproduzir o experimento localmente com os mesmos limites de CPU/RAM, sistema de arquivos \textit{read-only} e coleta de \textit{Web Vitals} no formato NDJSON, preservando a comparabilidade entre \acrshort{csr} e \acrshort{ssr}.


\subsection{Coleta de CPU/RAM do contÃªiner e exportaÃ§Ã£o em CSV}
\label{ssec:coleta-host-docker-stats}

Para registrar uso de CPU, memÃ³ria e nÃºmero de \textit{PIDs} dos contÃªineres durante os cenÃ¡rios de teste, foi utilizada a telemetria do prÃ³prio Docker via \texttt{docker stats} (sem streaming contÃ­nuo). As amostras foram coletadas a cada 1\,s e gravadas em arquivos CSV separados por aplicaÃ§Ã£o, no diretÃ³rio \texttt{metrics-host/}.

\subsubsection{Colunas dos CSVs.}
Cada linha contÃ©m:
\begin{itemize}
  \item \textbf{ts}: timestamp da coleta no host (\texttt{YYYY-MM-DD HH:MM:SS});
  \item \textbf{name}: nome do contÃªiner;
  \item \textbf{cpu\_perc}: percentual de CPU do contÃªiner (string com ``\%'' conforme \texttt{docker stats});
  \item \textbf{mem\_usage}: uso de memÃ³ria reportado (formato humano, ex.: ``123.4MiB / 1.00GiB'');
  \item \textbf{mem\_perc}: percentual de memÃ³ria (string com ``\%'');
  \item \textbf{pids}: quantidade de processos/threads visÃ­veis ao cgroup do contÃªiner.
\end{itemize}

\subsubsection{Coleta para o contÃªiner SSR (\texttt{next-ssr}).}
O comando abaixo cria o diretÃ³rio de mÃ©tricas (se nÃ£o existir) e inicia a captura contÃ­nua em \texttt{metrics-host/docker-stats-ssr.csv}:
\begin{lstlisting}[language=bash,caption={Captura de CPU/RAM do contÃªiner SSR e exportaÃ§Ã£o para CSV}]
mkdir -p metrics-host
(
  echo "ts,name,cpu_perc,mem_usage,mem_perc,pids";
  while true; do
    TS=$(date +"%F %T");
    docker stats --no-stream \
      --format "{{.Name}},{{.CPUPerc}},{{.MemUsage}},{{.MemPerc}},{{.PIDs}}" \
      next-ssr | sed "s/^/$TS,/";
    sleep 1;
  done
) >> metrics-host/docker-stats-ssr.csv
\end{lstlisting}

\subsubsection{Coleta para o contÃªiner CSR (\texttt{react-csr}).}
De forma anÃ¡loga, a coleta do contÃªiner CSR grava em \\ \texttt{metrics-host/docker-stats-csr.csv}:
\\
\\
\begin{lstlisting}[language=bash,caption={Captura de CPU/RAM do contÃªiner CSR e exportaÃ§Ã£o para CSV}]
(
  echo "ts,name,cpu_perc,mem_usage,mem_perc,pids";
  while true; do
    TS=$(date +"%F %T");
    docker stats --no-stream \
      --format "{{.Name}},{{.CPUPerc}},{{.MemUsage}},{{.MemPerc}},{{.PIDs}}" \
      react-csr | sed "s/^/$TS,/";
    sleep 1;
  done
) >> metrics-host/docker-stats-csr.csv
\end{lstlisting}





