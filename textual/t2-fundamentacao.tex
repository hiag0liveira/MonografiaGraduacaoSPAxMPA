\chapter{Fundamentação Teórica}
\label{cap:fundamentacao}

Este capítulo apresenta os conceitos de \english{\acrfull{csr}} e \english{\acrfull{ssr}}, abordando os princípios fundamentais do desenvolvimento web relacionados à renderização de conteúdo. Também são discutidos aspectos como \acrshort{seo}, desempenho, infraestrutura de serviços e impacto na experiência do usuário, estabelecendo a base teórica para o estudo de caso desenvolvido neste trabalho.

\section{Fundamentos de Desenvolvimento Web}
\label{sec:fundamentos-devweb}
Para entender como as abordagens \acrshort{ssr} e \acrshort{csr} se inserem no cenário de desenvolvimento web, é fundamental revisar protocolos, modelos de arquitetura e ferramentas.
Os fundamentos de desenvolvimento web englobam os princípios, tecnologias e práticas essenciais para a criação e manutenção de aplicações acessíveis via internet. 

O desenvolvimento web baseia-se na arquitetura cliente-servidor, onde o cliente (geralmente um navegador) solicita recursos ao servidor, que processa essas requisições e retorna os dados necessários. Essa interação é mediada por protocolos como o 
\english{\acrfull{http}} , que define as regras de comunicação entre cliente e servidor.

As tecnologias fundamentais incluem \english{\acrfull{html}} para estruturação do conteúdo, \english{\acrfull{css}} para estilização e JavaScript para interatividade. Essas linguagens permitem a construção de interfaces dinâmicas e responsivas. Além disso, o desenvolvimento web envolve práticas como controle de versão, testes automatizados e integração contínua, que garantem a qualidade e a escalabilidade das aplicações \cite{fundamentosDevWeb}. 

\subsection{Arquitetura Cliente-Servidor}
\label{subsec:Arquitetura Cliente-Servidor}

A arquitetura cliente-servidor é um modelo amplamente adotado no desenvolvimento de aplicações web, caracterizado pela separação entre dois componentes principais: cliente, responsável pela interface com o usuário, e o servidor, que processa solicitações e fornece os recursos necessários \cite{clienteServidorControlNet}.

Nesse modelo, os clientes como navegadores em diferentes dispositivos enviam requisições através da internet, enquanto os servidores respondem disponibilizando dados, arquivos e serviços. Essa divisão de responsabilidades favorece a escalabilidade, facilita a manutenção e permite que cliente e servidor operem em plataformas distintas~\cite{fundamentosDevWeb}.

A Figura~\ref{fig:cliente-servidor} ilustra, de forma simplificada, esse fluxo de comunicação entre cliente e servidor.

\begin{figure}[H]
  \centering
  \caption{Comunicação entre cliente e servidor.}
  \includegraphics[width=0.8\textwidth]{media/cliente_servidor.jpeg}
  \legend{Fonte: \cite{fundamentosDevWeb} }
  \label{fig:cliente-servidor}
\end{figure}


A arquitetura cliente-servidor apresenta características que contribuem para sua ampla adoção em aplicações web. Entre elas, destaca-se a distribuição de responsabilidades, onde o servidor gerencia dados e processos mais complexos, enquanto o cliente lida com a interface e a interação com o usuário. 

Outro ponto relevante é a independência entre plataformas, possibilitada pelo uso de protocolos padronizados, o que permite a comunicação entre diferentes dispositivos e sistemas operacionais. Além disso, esse modelo favorece a facilidade de manutenção, já que atualizações podem ser feitas no servidor sem necessidade de intervenção nos dispositivos dos usuários.

Na web, essa arquitetura é implementada por padrão: navegadores atuam como clientes, enviando requisições \acrshort{http} que são processadas por servidores, os quais respondem com páginas e recursos solicitados~\cite{fundamentosDevWeb}.


\subsection{Protocolo \acrshort{http}}
\label{subsec:http}
O Protocolo de Transferência de Hipertexto (\acrshort{http}) é a base da comunicação na World Wide Web, definindo como clientes (navegadores) e servidores trocam informações. Ele especifica a estrutura das requisições e respostas, permitindo a recuperação de recursos como documentos \acrshort(html), imagens e vídeos \cite{mdn_http}.


 O Funcionamento do \acrshort{http} opera no modelo cliente-servidor, onde o cliente inicia uma requisição e o servidor responde com os recursos solicitados ou mensagens de erro, se aplicável. Cada interação consiste em uma mensagem de requisição do cliente e uma mensagem de resposta do servidor. As mensagens \acrshort{http} são compostas por:

\begin{itemize}
    \item Linha de início: Indica o método \acrshort{http} (como \texttt{GET} ou \texttt{POST}) e o caminho do recurso.
    \item Cabeçalhos: Fornecem informações adicionais sobre a requisição ou resposta, como tipo de conteúdo e codificação.
    \item Corpo: Contém os dados enviados ou recebidos, sendo opcional dependendo do método utilizado.
\end{itemize}

\begin{flushright}
    \cite{mdn_http}
\end{flushright}


Métodos \acrshort{http} são operações definidas pelo protocolo que especificam a ação a ser realizada em um recurso. Os métodos mais comuns incluem:

\begin{itemize}
    \item GET: Solicita a representação de um recurso específico. Requisições GET devem ser utilizadas apenas para recuperar dados.
    \item POST: Envia dados ao servidor para processamento, como o envio de formulários.
    \item PUT: Atualiza um recurso existente ou cria um novo se não existir.
    \item DELETE: Remove um recurso específico.
    \item HEAD: Similar ao GET, mas solicita apenas os cabeçalhos da resposta, sem o corpo.
\end{itemize}

Cada método possui uma finalidade específica e deve ser utilizado conforme a necessidade da aplicação \cite{wikipedia_http}.


Códigos de Status \acrshort{http} são códigos de três dígitos que indicam o resultado de uma requisição feita pelo cliente ao servidor. Eles são agrupados em cinco classes principais:

\begin{itemize}
    \item 1xx (Informativo): Indica que a requisição foi recebida e o processo continua.
    \item 2xx (Sucesso): Indica que a requisição foi bem-sucedida. Exemplo: 200 OK.
    \item 3xx (Redirecionamento): Indica que é necessário tomar medidas adicionais para completar a requisição. Exemplo: 301 Moved Permanently.
    \item 4xx (Erro do Cliente): Indica que houve um erro na requisição do cliente. Exemplo: 404 Not Found.
    \item 5xx (Erro do Servidor): Indica que o servidor falhou ao processar uma requisição válida. Exemplo: 500 Internal Server Error.
\end{itemize}

Esses códigos auxiliam na identificação e resolução de problemas durante a comunicação \acrshort{http} \cite{mdn_http}.


Evolução do \acrshort{http} refere-se às revisões progressivas do protocolo com o objetivo de aprimorar sua eficiência e desempenho ao longo do tempo. As principais versões são:

\begin{itemize}
    \item HTTP/1.0: Primeira versão oficial do protocolo, em que cada requisição exigia uma nova conexão com o servidor.
    \item HTTP/1.1: Introduziu conexões persistentes, permitindo múltiplas requisições por conexão. Trouxe também melhorias no controle de cache e suporte a novos métodos.
    \item HTTP/2: Implementou multiplexação, compressão de cabeçalhos e priorização de fluxos, resultando em uma transferência de dados mais rápida e eficiente.
    \item HTTP/3: Baseado no protocolo \acrshort{quic}, substitui o \acrshort{tcp} pelo \acrshort{udp}, oferecendo conexões mais rápidas e seguras, com menor latência e melhor desempenho em redes instáveis.
\end{itemize}

Essas atualizações refletem a evolução das necessidades da web e a busca por protocolos mais robustos e otimizados \cite{cloudflare_http}.

\acrshort{http} e \acrshort{https} representam protocolos utilizados para comunicação na web, com a principal distinção centrada na segurança da transmissão dos dados.

O \english{\acrfull{https}} é uma extensão do \acrshort{http} que adiciona uma camada de proteção por meio do protocolo \english{\acrfull{tls}} ou, anteriormente, \english{\acrfull{ssl}}. Essa camada de segurança garante a confidencialidade, integridade e autenticidade dos dados trafegados entre cliente e servidor.

A criptografia utilizada impede que terceiros acessem ou modifiquem as informações transmitidas, o que é fundamental em transações sensíveis, como cadastros, pagamentos e autenticações. Além disso, o uso de \textit{certificados digitais} garante que o site visitado é realmente aquele que afirma ser, protegendo os usuários contra ataques como o \textit{man-in-the-middle}\footnote{Um ataque \textit{man-in-the-middle} ocorre quando um invasor intercepta e possivelmente altera a comunicação entre duas partes que acreditam estar se comunicando diretamente. Isso pode permitir que o invasor capture informações sensíveis ou injete dados maliciosos na comunicação.\cite{wikipedia_man_in_the_middle}}.

Enquanto o \acrshort{http} tradicional opera normalmente na porta \acrshort{tcp} 80, o \acrshort{https} utiliza, por convenção, a porta 443. Atualmente, o uso do \acrshort{https} é fortemente recomendado e até exigido por navegadores modernos como padrão de segurança para qualquer aplicação web, contribuindo para a privacidade e confiança dos usuários \cite{wikipedia_http}.

\subsection{\acrshort{html}, \acrshort{css} e JavaScript}
\label{subsec:html-css-js}


O desenvolvimento frontend, conforme definido por \citeonline{aws_frontend_backend}, refere-se à camada de apresentação de uma aplicação web a interface gráfica com a qual os usuários interagem diretamente, composta por menus, botões, formulários e outros elementos visuais. Essa camada baseia-se em um conjunto de tecnologias fundamentais que operam em conjunto para fornecer estrutura, estilo e interatividade às páginas: \acrshort{html}, \acrshort{css} e JavaScript. Cada uma dessas linguagens desempenha um papel específico e complementar, sendo essenciais tanto em abordagens tradicionais quanto em técnicas modernas como o \acrshort{csr}.


\acrfull{html} é a linguagem de marcação padrão para a criação da estrutura de páginas web. Através de um conjunto de elementos (ou \textit{tags}), o \acrshort{html} organiza e define o conteúdo exibido ao usuário, como textos, imagens, links, formulários e tabelas. Além de estruturar visualmente o documento, o \acrshort{html} também confere semântica aos elementos, facilitando a indexação por motores de busca e promovendo acessibilidade para leitores de tela. Elementos como \texttt{<header>}, \texttt{<main>}, \texttt{<article>} e \texttt{<footer>} exemplificam essa função semântica~\cite{alura_htmlcssjs}.

\acrfull{css} é a linguagem responsável pela estilização das páginas web. Com o \acrshort{css}, define-se a aparência dos elementos estruturados no \acrshort{html}, controlando propriedades visuais como cores, fontes, espaçamentos, tamanhos e posicionamentos. O \acrshort{css} permite ainda a construção de layouts complexos e responsivos, adaptando o conteúdo para diferentes tamanhos de tela e dispositivos. A separação entre estrutura (\acrshort{html}) e estilo (\acrshort{css}) é um dos pilares das boas práticas em desenvolvimento web, promovendo manutenibilidade, reutilização e modularidade do código.

Entre os recursos modernos do \acrshort{css}, destacam-se os seletores avançados, variáveis \acrshort{css}, pseudo-classes, animações e as funcionalidades de \textit{Flexbox} e \textit{Grid}, que facilitam a criação de interfaces ricas e adaptáveis~\cite{herocode_diferencas}.

JavaScript é uma linguagem de programação interpretada, orientada a objetos e baseada em eventos, amplamente utilizada para adicionar interatividade e dinamismo às páginas web. Por meio da manipulação da \textit{\acrfull{dom}}, permite implementar funcionalidades como respostas a cliques, envio de formulários, movimentações do mouse, digitação, animações, validações e atualizações em tempo real, enriquecendo significativamente a experiência do usuário~\cite{alura_htmlcssjs}. Além disso, possibilita o carregamento assíncrono de dados com a técnica \textit{AJAX} (\textit{Asynchronous JavaScript and XML}), evitando recarregamentos completos da página.

JavaScript é uma das três principais tecnologias da World Wide Web, juntamente com \acrshort{html} e \acrshort{css}, sendo essencial tanto em abordagens tradicionais quanto modernas. Nas aplicações baseadas em \acrshort{csr}, essa linguagem tem papel central, pois a renderização das páginas ocorre diretamente no navegador do usuário. Com a evolução do ecossistema JavaScript, surgiram bibliotecas e frameworks robustos como a biblioteca React e os frameworks Vue.js e Angular que facilitam o desenvolvimento de aplicações complexas com componentes reutilizáveis e gerenciamento eficiente de estado.

Adicionalmente, o JavaScript também pode ser executado no lado do servidor (\acrshort{ssr}) por meio de ambientes como o Node.js uma plataforma de código aberto e multiplataforma baseada em eventos e não bloqueante, ideal para aplicações escaláveis e em tempo real~\cite{nodejs2025, js2025}. Isso permite o desenvolvimento de aplicações completas utilizando uma única linguagem em ambas as camadas, cliente e servidor.

A interação entre essas três tecnologias pode ser compreendida por meio de uma analogia: o \acrshort{html} representa a estrutura de um corpo (esqueleto), o \acrshort{css} corresponde à sua aparência externa (pele, roupas, estilo), enquanto o JavaScript age como os músculos e o sistema nervoso, controlando os movimentos e respostas interativas da aplicação. A Figura~\ref{fig:html-css-js} ilustra essa relação.

\begin{figure}[H]
  \centering
  \caption{Analogia entre HTML, CSS e JavaScript e os componentes de um corpo humano.}
  \includegraphics[width=0.6\textwidth]{media/html_css_js_analogia.png}
  \legend{Fonte: \cite{herocode_diferencas}.}
  \label{fig:html-css-js}
\end{figure}

Portanto, o domínio dessas três tecnologias é indispensável para qualquer desenvolvedor web. Elas formam o alicerce sobre o qual se constroem interfaces acessíveis, performáticas e envolventes, sendo empregadas tanto em aplicações renderizadas no servidor (\acrshort{ssr}) quanto no cliente (\acrshort{csr}), com adaptações específicas conforme a abordagem escolhida.



\section{Renderização na Web}
\label{sec:renderizacao-web}

A renderização na Web diz respeito ao processo de transformar dados em conteúdo visual interpretável pelo navegador. A escolha sobre onde e como essa renderização será realizada (seja no cliente, no servidor ou em tempo de build), isso impacta diretamente métricas como tempo de carregamento, interatividade e indexação por mecanismos de busca \cite{osmani2025}.


\subsection{\acrfull{spa} e \acrfull{mpa}}
\label{subsec:spa-mpa}

As arquiteturas \acrfull{spa} e \acrfull{mpa} representam duas abordagens distintas para a estrutura de navegação e carregamento de conteúdo em aplicações web.

As \acrshort{spa}s são aplicações em que a navegação entre páginas ocorre sem recarregamentos completos do navegador. Após o carregamento inicial, todo o conteúdo adicional é gerenciado dinamicamente com JavaScript, o que proporciona uma experiência mais fluida e interativa. Essa abordagem é comumente utilizada em conjunto com a renderização no lado do cliente (\acrshort{csr}) e frameworks como React, Angular ou Vue.js \cite{atori2024}.

Já as \acrshort{mpa}s seguem o modelo tradicional de navegação, em que cada clique em um link leva a uma nova requisição \acrshort{http} e recarregamento completo da página. Essa arquitetura é naturalmente mais compatível com a renderização no lado do servidor (\acrshort{ssr}) e favorece aspectos como \acrshort{seo}, acessibilidade e previsibilidade de comportamento \cite{osmani2025}.

A escolha entre \acrshort{spa} e \acrshort{mpa} está diretamente ligada à estratégia de renderização adotada. As \acrshort{spa}s tendem a oferecer experiências mais ricas e responsivas, mas exigem cuidados extras com desempenho e indexação. Por outro lado, as \acrshort{mpa}s são mais robustas em cenários com grande volume de tráfego e requisitos de otimização para mecanismos de busca.



\subsection{Estratégias e Terminologias de Renderização}
\label{subsec:estrategias-terminologias}

Segundo \citeonline{osmani2025}, é importante distinguir os principais modelos de renderização:


\begin{description}
  \item[Client-Side Rendering (CSR)] 
  O conteúdo da aplicação é gerado dinamicamente no navegador, utilizando JavaScript. A página HTML inicial contém apenas uma estrutura básica com os scripts necessários para montar a interface após o carregamento. É comum em aplicações do tipo SPA (Single Page Application).
  
  \item[Server-Side Rendering (SSR)]
  O servidor monta todo o conteúdo da página em HTML antes de enviá-lo ao cliente. Isso permite uma exibição mais rápida do conteúdo, mesmo em conexões lentas, e melhora a indexação por mecanismos de busca.

  \item[Static Site Generation (SSG)]
  As páginas são geradas de forma estática em tempo de build, com base em dados disponíveis no momento da compilação. O conteúdo é entregue diretamente por uma CDN, garantindo alto desempenho.

  \item[Incremental Static Regeneration (ISR)]
  Introduzido pelo Next.js, o ISR permite que páginas geradas estaticamente possam ser atualizadas de forma incremental, após um período de tempo definido. Isso é feito em segundo plano, sem bloquear o carregamento da página atual. Ideal para sites com atualizações frequentes, mas não críticas em tempo real.

  \item[Deferred Static Generation (DSG)]
  Proposto pelo Gatsby, o DSG difere do ISR por não gerar certas páginas no momento do build. Em vez disso, elas são geradas apenas na primeira requisição (on-demand). Após isso, são armazenadas em cache e servidas como estáticas nas requisições seguintes. É útil em projetos com milhares de páginas de baixo acesso, reduzindo significativamente o tempo de build.
\end{description}

Além dessas abordagens, destaca-se o conceito de reidratação, que consiste em ativar a interatividade de páginas SSR ou SSG no cliente. Esse processo utiliza JavaScript para associar os eventos dinâmicos à estrutura HTML previamente renderizada, sendo essencial para tornar a página interativa após a exibição inicial \cite{osmani2025}.


\subsubsection{Desempenho e Compensações}

A renderização do lado do servidor tende a exibir conteúdo mais rapidamente (menor \acrshort{fcp}), favorecendo acessibilidade e \acrshort{seo}. No entanto, pode aumentar o \acrshort{ttfb}, já que a página precisa ser processada antes de ser enviada \cite{osmani2025}. Já a renderização no cliente pode reduzir o tempo de resposta inicial do servidor, mas exige mais do navegador e aumenta o tempo até a página estar interativa \acrfull{tti}, especialmente em dispositivos móveis.

Modelos híbridos como \acrshort{ssr} com \textit{hydration} tentam unir os benefícios de ambas as abordagens, mas podem causar atrasos na interatividade. Técnicas como \textit{hydration progressiva} ou \textit{streaming} reduzem esses impactos ao ativar partes da interface conforme necessário \cite{osmani2025}. Estratégias mais recentes, como a renderização trimórfica, permitem que a renderização ocorra em três camadas: servidor, cliente e \textit{service worker}. Isso possibilita desempenho superior em acessos repetidos e melhor controle sobre o cache e atualização de conteúdo dinâmico \cite{osmani2025}.

\subsubsection{Impacto em SEO e Indexação}

Segundo \citeonline{osmani2025}, abordagens que entregam HTML completo como \acrshort{ssr} e \acrshort{ssg} são mais eficazes para indexação por mecanismos de busca. Já modelos que dependem fortemente de JavaScript (\acrshort{csr}) exigem testes adicionais e podem comprometer a visibilidade em sistemas como o Googlebot, especialmente quando há falhas na execução dos scripts.

\begin{figure}[H]
  \centering
  \caption{Comparativo entre estratégias de renderização}
  \includegraphics[width=\textwidth]{media/rendering_comparison_table.png}
  \legend{Fonte: Adaptado de \cite{osmani2025}}
  \label{fig:comparativo_renderizacao}
\end{figure}

A Figura~\ref{fig:comparativo_renderizacao} oferece uma visão consolidada e detalhada de cinco estratégias de renderização web, do modelo puramente do servidor ao puramente do cliente. A tabela ilustra os \textit{trade-offs} de cada abordagem em relação a aspectos como o papel do servidor, o tipo de HTML gerado e os impactos em desempenho e escala.

\begin{itemize}
    \item \acrshort{ssr} com (Re)hydration: O servidor pré-renderiza a página, mas a aplicação completa também é carregada no cliente. Embora o HTML inicial seja dinâmico, o JavaScript é responsável por tornar a página interativa, o que pode resultar em um atraso considerável entre a exibição do conteúdo e a interatividade completa (\acrshort{tti} >> \acrshort{fcp}). Este modelo é mais flexível, mas pode levar a um \acrshort{ttfb} mais lento e a uma experiência "embaçada" (\textit{buffered}) para o usuário.

    \item \acrshort{ssr} (Server Rendering): Neste modelo, a aplicação é inteiramente renderizada no servidor, que responde a cada requisição de navegação com um HTML dinâmico completo. A principal vantagem é que o tempo de interatividade (\acrshort{tti}) é igual ao tempo até o primeiro conteúdo (\acrshort{fcp}), e o conteúdo é totalmente transmitido em \textit{streaming}. Contudo, ele pode ter um \acrshort{ttfb} mais lento e é considerado inflexível.

    \item "Static \acrshort{ssr}" (\acrshort{ssg}): As páginas são pré-renderizadas para HTML estático em tempo de \textit{build} e o JavaScript é removido. Essa abordagem é construída como um SPA, mas entrega um HTML estático que é servido diretamente ao cliente. Os benefícios incluem um rápido \acrshort{ttfb} e o \acrshort{tti} ser igual ao \acrshort{fcp}, com a desvantagem de ser inflexível e ter que passar pela \textit{hydration} para interatividade.

    \item \acrshort{csr} com Prerendering: A página é um SPA onde um "esqueleto" ou \textit{shell} inicial é pré-renderizado para HTML estático durante o \textit{build}. O servidor entrega apenas esse HTML parcial e o JavaScript/DOM são injetados posteriormente para renderizar o conteúdo. É uma abordagem flexível e com um \acrshort{ttfb} rápido, mas o \acrshort{tti} ainda é maior que o \acrshort{fcp}.

    \item Full \acrshort{csr}: Toda a lógica, renderização e inicialização da aplicação são feitas no cliente. O HTML enviado pelo servidor é basicamente um conjunto de \textit{tags} de \textit{script} e estilo. É uma abordagem flexível com um \acrshort{ttfb} rápido, mas sofre com um grande atraso entre a renderização inicial e a interatividade (\acrshort{tti} >>> \acrshort{fcp}).
\end{itemize}

Em resumo, a figura demonstra que a escolha da renderização é um compromisso estratégico entre a velocidade de exibição inicial do conteúdo e a interatividade, com cada abordagem influenciando a carga computacional no servidor ou no navegador.

\subsection{\english{Client-Side Rendering} (\acrshort{csr})}
\label{subsec:csr}

 \english{\acrfull{csr}} é uma técnica em que a geração da interface e do conteúdo final ocorre diretamente no navegador do usuário, utilizando JavaScript. Nessa abordagem, o servidor envia um arquivo \english{\acrfull{html}} mínimo, contendo apenas a estrutura básica da página e referências a arquivos de estilo e scripts.{\cite{atori2024}}

Segundo \citeonline{atori2024}, o processo de renderização no cliente segue as seguintes etapas:

\begin{enumerate}
    \item O servidor envia uma página \acrshort{html} em branco contendo apenas links para os arquivos \english{\acrfull{css}} e JavaScript.
    \item O navegador interpreta o \acrshort{html} e constrói a árvore do \english{\acrfull{dom}}
    \item Os arquivos de estilo (\acrshort{css}) e script (JavaScript) são baixados pelo navegador.
    \item A aplicação é renderizada dinamicamente pelo JavaScript, incluindo elementos visuais como texto, imagens e botões.
    \item O conteúdo da página é atualizado de forma interativa conforme o usuário interage com a aplicação.
\end{enumerate}

Esse modelo é comumente utilizado em aplicações \english{\acrfull{spa}}, nas quais o carregamento inicial é seguido por atualizações dinâmicas sem recarregamento da página. Ferramentas como a biblioteca React, e frameworks como Vue.js, Angular e Svelte são amplamente utilizadas para implementar \acrshort{csr}, permitindo o desenvolvimento de interfaces dinâmicas, interativas e responsivas.


A renderização no lado do cliente (\acrshort{csr}) é especialmente vantajosa em aplicações que exigem alta interatividade e atualizações frequentes de conteúdo, como redes sociais, plataformas de streaming e jogos online. No entanto, essa abordagem pode apresentar desvantagens em termos de desempenho inicial e \acrshort{seo}, uma vez que o conteúdo só é exibido após a execução do JavaScript, o que pode impactar negativamente a indexação por motores de busca e a experiência do usuário em conexões lentas \cite{atori2024}.

\begin{figure}[h!]
    \centering
    \caption{Etapas do método de renderização no lado do cliente}
    \includegraphics[width=0.8\textwidth]{media/client_side_rendering.png}
    \legend{Fonte: \cite{atori2024} (adaptado)}
    \label{fig:client_side_rendering}
\end{figure}


A \autoref{fig:client_side_rendering} ilustra visualmente o fluxo completo da renderização no lado do cliente (\acrshort{csr}). O processo é iniciado quando o usuário acessa o site em questão. Em resposta, o servidor envia o arquivo \acrshort{html} básico, contendo apenas links para os arquivos de estilo \acrshort{css} e scripts JavaScript responsáveis por carregar e renderizar o conteúdo da aplicação.

Na sequência, o navegador interpreta esse \acrshort{html} e constrói a estrutura da página por meio da árvore \acrshort{dom}. No entanto, o conteúdo principal ainda não está visível. O navegador então precisa baixar os arquivos de estilo (\acrshort{css}) e os scripts JavaScript referenciados no documento inicial.

Com os scripts carregados, o navegador executa o código JavaScript, que normalmente utiliza bibliotecas ou frameworks como React ou Vue para gerar dinamicamente o conteúdo da aplicação. Somente após essa etapa o conteúdo completo do site é finalmente exibido ao usuário, quando o navegador conclui o processo de renderização e o site é carregado completamente.

\begin{codigo}[H]
  \begin{lstlisting}[language=html]
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CryptoWebsite</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>*,*:before,*:after{margin:0;padding:0;box-sizing:border-box;
    font-family:Inter,sans-serif}html{font-size:62.5%}</style>
  <link rel="stylesheet" href="styles.9d4c7581c7242.css">
</head>
<body>
  <app-root></app-root>
  <script src="runtime.6170988ad52a05db.js" type="module"></script>
  <script src="polyfills.574970d5ec4bdb97.js" type="module"></script>
  <script src="main.202d37bb6740400e.js" type="module"></script>
</body>
</html>
\end{lstlisting}
  \caption{Exemplo de HTML mínimo em aplicação Angular com CSR}
  \label{lst:angular_html}
\end{codigo}

Esse padrão é típico de aplicações \acrshort{spa}, onde todo o conteúdo é inserido dinamicamente a partir da execução dos arquivos JavaScript. O elemento \texttt{<app-root>} funciona como ponto de entrada da aplicação, sendo substituído no navegador pelos componentes definidos no framework Angular. {\cite{atori2024}}


\subsection{\english{Server-Side Rendering} (\acrshort{ssr})}
\label{subsec:ssr}

 \english{\acrfull{ssr}} é uma abordagem em que a geração do conteúdo e da interface ocorre integralmente no servidor antes de ser enviada ao navegador do cliente. Ou seja, o servidor processa a lógica da aplicação, obtém dados necessários (por exemplo, em bancos de dados ou \emph{APIs}) e retorna ao cliente um arquivo \english{\acrshort{html}} já renderizado. Dessa forma, o navegador exibe imediatamente a página completa, sem precisar executar \emph{scripts} para montar o conteúdo inicial \cite{atori2024}. 

Segundo \citeonline{atori2024}, o processo típico de renderização no lado do servidor pode ser descrito em quatro etapas principais:

\begin{enumerate}
    \item O servidor recebe uma requisição para uma página e recupera os dados necessários para compor seu conteúdo (por exemplo, produtos de uma base de dados ou artigos de um blog).
    \item O servidor insere esses dados em um \emph{template} \acrshort{html}, gerando a estrutura final da página.
    \item Em seguida, o servidor aplica estilos e finaliza a renderização, resultando em um documento \acrshort{html} completamente montado.
    \item Por fim, esse documento \acrshort{html} é enviado ao navegador do usuário, exibindo a página prontamente, sem a necessidade de executar \emph{JavaScript} durante o carregamento inicial.
\end{enumerate}

Nesse modelo, a fase de hydration\footnote{Hydration é uma etapa essencial no \acrshort{ssr}, em que o JavaScript torna interativo o conteúdo HTML previamente renderizado no servidor.} ocorre após o carregamento inicial da página. costuma ocorrer após a entrega do conteúdo estático. Significa que, assim que o arquivo \acrshort{html} é carregado e mostrado ao usuário, o \emph{JavaScript} do lado do cliente assume o controle para tratar as interações e atualizações dinâmicas subsequentes. Dessa forma, o \acrshort{ssr} beneficia tanto o primeiro acesso (tornando o conteúdo visível rapidamente) quanto o \acrshort{seo}, por exibir ao rastreador dos mecanismos de busca um código \acrshort{html} completo. \cite{atori2024}.

\begin{figure}[H]
  \centering
  \caption{Etapas do método de renderização no lado do servidor}
  \includegraphics[width=0.8\textwidth]{media/server_side_rendering.jpeg}
  \legend{Fonte: \cite{atori2024} (adaptado)}
  \label{fig:server_side_rendering}
\end{figure}

A \autoref{fig:server_side_rendering} ilustra o fluxo de uma aplicação \acrshort{ssr}. Ao receber a requisição, o servidor gera a página completa em \acrshort{html} e a envia ao cliente. Essa estratégia costuma ser vantajosa em cenários onde o carregamento inicial rápido e a indexação por motores de busca são prioridades, como em sites de e-commerce e páginas de \emph{landing}, permitindo que o usuário visualize o conteúdo de forma imediata. 

\emph{Meta-frameworks} como Next.js, Nuxt.js, SvelteKit, Angular Universal, Remix, Astro e Qwik são amplamente utilizados para construir aplicações com suporte a \acrshort{ssr}. Esses frameworks operam em um nível superior aos tradicionais (como React, Vue ou Svelte), agregando funcionalidades comuns ao desenvolvimento web, como roteamento, pré-renderização, recuperação de dados e \emph{hydration} podendo oferecer uma estrutura mais completa, opinativa e voltada à escalabilidade.

O \acrshort{ssr} é especialmente útil em aplicações que exigem um carregamento inicial rápido e uma boa indexação por motores de busca, como sites de e-commerce, blogs e páginas de \emph{landing}. Essa abordagem permite que o usuário visualize o conteúdo imediatamente, sem esperar pela execução do JavaScript. Além disso, o \acrshort{ssr} melhora a \acrshort{seo}, pois os mecanismos de busca conseguem indexar o conteúdo completo da página desde o início.

No \autoref{cod:nextjs_html}, pode-se observar que o arquivo \acrshort{html} já contém todo o \emph{markup} necessário para exibir o conteúdo da página. Assim que o navegador recebe esse arquivo, o usuário já visualiza o cabeçalho, o texto e o layout definidos. Posteriormente, o \emph{JavaScript} baixado (por exemplo, \texttt{main.js}) pode entrar em ação para lidar com eventos, rotas adicionais e atualizações dinâmicas, caso o desenvolvedor deseje funcionalidades mais interativas.

Por fim, aplicações \acrshort{ssr} tendem a apresentar melhor performance em termos de \emph{time-to-first-byte}\footnote{O \emph{time-to-first-byte} (TTFB) é uma métrica que mede o tempo decorrido entre o envio de uma solicitação HTTP pelo cliente e o recebimento do primeiro byte da resposta do servidor. Um TTFB menor indica maior rapidez na resposta do servidor, impactando diretamente na velocidade de carregamento da página e na experiência do usuário. \cite{ttfb-craig}} e de \emph{indexabilidade}\footnote{A \emph{indexabilidade} refere-se à capacidade dos motores de busca de rastrear e indexar o conteúdo de uma página web. Aplicações SSR, ao fornecerem conteúdo totalmente renderizado no servidor, facilitam a indexação eficiente pelos motores de busca, melhorando a visibilidade nos resultados de pesquisa. \cite{ttfb-oskay}} por motores de busca, ao mesmo tempo em que podem demandar maior carga de processamento no servidor. A escolha por \acrshort{ssr} ou não, portanto, depende do perfil da aplicação e das prioridades do projeto, considerando fatores como volume de tráfego, necessidade de interatividade e requisitos de otimização de conteúdo.

\begin{codigo}[H]
  \begin{lstlisting}[language=html]
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <title>My SSR App</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        /* Exemplo simples de estilo inline */
        body {
          margin: 0;
          font-family: Arial, sans-serif;
          background: #f6f6f6;
        }
        h1 { color: #333; }
      </style>
    </head>
    <body>
<!-- Conteudo ja processado e inserido no servidor -->
      <div id="__next">
        <header>
          <h1>Ola, mundo!</h1>
        </header>
        <main>
          <p>Este conteudo foi renderizado no servidor usando Next.js.</p>
        </main>
      </div>
      <!-- Scripts do Next.js para interacao no cliente -->
      <script src="/_next/static/chunks/main.js" defer></script>
    </body>
    </html>
  \end{lstlisting}
  \caption{Exemplo de HTML mínimo em aplicação Next.js com SSR}
  \label{cod:nextjs_html}
\end{codigo}

\subsection{\english{Static Site Generation} (\acrshort{ssg})}
\label{subsec:ssg}

\english{\acrfull{ssg}} é uma técnica de pré-renderização na qual as páginas da aplicação são geradas estaticamente em tempo de *build* (compilação) e armazenadas como arquivos \acrshort{html}. Ao contrário de abordagens como \acrshort{csr} e \acrshort{ssr}, onde a renderização ocorre no navegador ou sob demanda no servidor, o \acrshort{ssg} permite que o conteúdo já esteja pronto e otimizado para ser entregue diretamente ao navegador, reduzindo a carga do servidor e otimizando o desempenho de carregamento \cite{pahan2021}.

Segundo \citeonline{bose2022}, a renderização no modelo \acrshort{ssg} segue estas etapas principais:

\begin{enumerate}
    \item Durante o processo de construção (build), o gerador de sites estáticos coleta dados de fontes como arquivos locais, \emph{APIs} ou bancos de dados.
    \item Esses dados são utilizados para gerar arquivos \acrshort{html} completos para cada rota da aplicação.
    \item Os arquivos gerados são armazenados e podem ser servidos diretamente por uma \emph{CDN} (Content Delivery Network).
    \item Quando o usuário acessa a aplicação, os arquivos estáticos são entregues instantaneamente, sem necessidade de renderização adicional.
\end{enumerate}

Essa abordagem é ideal para páginas cujo conteúdo não muda com frequência, como blogs, documentações, portfólios e sites institucionais. Como os arquivos são pré-gerados, o tempo de resposta é extremamente rápido, e o \acrshort{seo} é favorecido, já que os mecanismos de busca encontram o conteúdo pronto para indexação.

\begin{figure}[H]
  \centering
  \caption{Etapas do método de geração estática de páginas (SSG)}
  \includegraphics[width=0.8\textwidth]{media/static_site_generation.png}
  \legend{Fonte: \cite{bose2022} (adaptado)}
  \label{fig:ssg}
\end{figure}

Frameworks como Next.js, Gatsby, Hugo e Jekyll oferecem suporte completo ao \acrshort{ssg}, integrando funcionalidades como roteamento dinâmico, \emph{markdown}, e integração com CMSs. No exemplo a seguir, observa-se um documento \acrshort{html} gerado estaticamente por meio de um processo de \emph{build}:

\begin{codigo}[H]
  \begin{lstlisting}[language=html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Post: SSG Example</title>
  </head>
  <body>
    <article>
      <h1>Exemplo de página gerada com SSG</h1>
      <p>Esse conteúdo foi gerado em tempo de build.</p>
    </article>
  </body>
</html>
  \end{lstlisting}
  \caption{Exemplo de HTML estático gerado com SSG}
  \label{cod:ssg_example}
\end{codigo}

A principal limitação do \acrshort{ssg} é a dificuldade em lidar com conteúdos altamente dinâmicos. Alterações nos dados requerem um novo processo de build para que as páginas sejam atualizadas, o que pode ser custoso em grandes aplicações ou com frequência de atualização elevada.

\subsection{\english{Incremental Static Regeneration} (\acrshort{isr})}
\label{subsec:isr}

\english{\acrfull{isr}} é uma estratégia híbrida introduzida por frameworks como o Next.js, que combina os benefícios da geração estática (\acrshort{ssg}) com a flexibilidade de atualização dinâmica. Com \acrshort{isr}, as páginas são inicialmente geradas estaticamente em tempo de build, mas podem ser revalidadas e regeneradas no servidor de forma incremental e automática, com base em uma estratégia de tempo (ex: a cada 10 segundos) ou conforme novas requisições são feitas \cite{pahan2021}.

De acordo com \citeonline{bose2022}, o fluxo típico do \acrshort{isr} inclui as seguintes etapas:

\begin{enumerate}
    \item No momento do build inicial, as páginas são geradas e armazenadas como arquivos estáticos.
    \item Ao ser requisitada por um usuário, a página é entregue imediatamente, com o conteúdo pré-renderizado.
    \item Se o tempo de revalidação definido (ex: \texttt{revalidate: 60}) tiver expirado, uma nova requisição ao backend é feita em segundo plano.
    \item Essa nova versão da página é armazenada e substitui a anterior, sendo usada em acessos futuros.
\end{enumerate}

Essa abordagem permite obter performance e \acrshort{seo} semelhantes ao \acrshort{ssg}, mas com a vantagem de manter o conteúdo atualizado sem precisar de reconstruções manuais. Por isso, o \acrshort{isr} é ideal para sites que possuem atualizações regulares, porém não críticas em tempo real, como catálogos de produtos, blogs com comentários ou páginas de notícias.

\begin{figure}[H]
  \centering
  \caption{Funcionamento do modelo Incremental Static Regeneration (ISR)}
  \includegraphics[width=0.8\textwidth]{media/incremental_static_regeneration.png}
  \legend{Fonte: \cite{pahan2021}}
  \label{fig:isr}
\end{figure}

Abaixo, um exemplo típico em Next.js:

\begin{codigo}[H]
  \begin{lstlisting}[language=JavaScript]
      // Funcao usada em getStaticProps
      export async function getStaticProps() {
        const res = await fetch('https://api.exemplo.com/posts')
        const posts = await res.json()

        return {
          props: { posts },
          revalidate: 60, // Pagina sera regenerada a cada 60 segundos
          }
      }
  \end{lstlisting}
  \caption{Exemplo de revalidação de conteúdo com ISR no Next.js}
  \label{cod:isr_next}
\end{codigo}


O \acrshort{isr} representa um meio-termo eficiente entre a performance do \acrshort{ssg} e a flexibilidade do \acrshort{ssr}, oferecendo escalabilidade, \acrshort{seo} eficiente e atualização contínua do conteúdo, sem prejudicar a experiência do usuário.




\subsection{\english{Deferred Static Generation} (\acrshort{dsg})}
\label{subsec:deferred-dsg}

\english{Deferred Static Generation} (DSG) é uma extensão da estratégia de geração estática proposta pelo framework Gatsby. Essa abordagem permite que certas páginas do site sejam geradas sob demanda ( ou seja, somente no momento em que forem requisitadas pela primeira vez ) em vez de serem construídas durante o processo inicial de build, como ocorre no \acrshort{ssg} tradicional \cite{gatsby2023}.

Segundo a \citeonline{gatsby2023}, o \acrshort{dsg} tem como principal vantagem a capacidade de reduzir significativamente o tempo de build em projetos com um número elevado de páginas, ao evitar a pré-renderização de rotas que têm baixo tráfego ou que não precisam estar imediatamente disponíveis. Após a primeira solicitação, a página é armazenada em cache e, a partir daí, servida como conteúdo estático em acessos subsequentes.

O fluxo típico de geração diferida no \acrshort{dsg} ocorre da seguinte forma:

\begin{enumerate}
    \item Durante o processo de build, apenas páginas prioritárias são pré-geradas.
    \item Páginas marcadas como \texttt{defer} são ignoradas temporariamente.
    \item Quando uma página \acrshort{dsg} é acessada pela primeira vez, um \textit{worker} do Gatsby gera a versão \acrshort{html} da página com base em um componente React (ex: \texttt{about.js}).
    \item A página gerada é armazenada em cache e servida como conteúdo estático nas próximas requisições.
\end{enumerate}

\begin{figure}[H]
  \centering
  \caption{Funcionamento da estratégia Deferred Static Generation (DSG)}
  \includegraphics[width=0.9\textwidth]{media/deferred_static_generation_dsg.png}
  \legend{Fonte: \cite{gatsby2023}}
  \label{fig:deferred_dsg}
\end{figure}

Na \autoref{fig:deferred_dsg}, observa-se que, ao acessar uma página como \texttt{/about} pela primeira vez, ocorre um \textit{cache miss}, e um \textit{worker} do Gatsby é acionado para gerar o arquivo \texttt{about.html} a partir do componente correspondente (\texttt{about.js}). Esse conteúdo pode incluir dados extraídos de plugins, \textit{APIs} de terceiros ou do próprio \textit{Gatsby DB}. Após o processamento, a resposta é enviada ao usuário e armazenada em cache. Requisições futuras à mesma rota são atendidas diretamente pela CDN, com desempenho semelhante ao de páginas \acrshort{ssg}.

Segundo \citeonline{locofy2024}, a estratégia do \acrshort{dsg} é especialmente útil para projetos com milhares de páginas cujo acesso é desigual. Exemplos incluem catálogos de produtos legados, páginas de arquivos antigos ou conteúdos gerados a partir de sistemas CMS.

A seguir, um exemplo de configuração de uma rota com \acrshort{dsg} em Gatsby:

\begin{codigo}[H]
  \begin{lstlisting}[language=JavaScript]
// gatsby-node.js
exports.createPages = async ({ actions }) => {
  const { createPage } = actions
  createPage({
    path: `/produto/exemplo`,
    component: require.resolve(`./src/templates/produto.js`),
    context: { id: `produto-exemplo` },
    defer: true, // ativa DSG
  })
}
  \end{lstlisting}
  \caption{Exemplo de definição de página DSG no Gatsby}
  \label{cod:dsg_example}
\end{codigo}

Assim como o \acrshort{isr}, o \acrshort{dsg} busca combinar desempenho, escalabilidade e atualizações eficientes. No entanto, sua particularidade está em adiar completamente o custo da renderização até o momento da primeira requisição, tornando-o ideal em contextos onde o tempo de build precisa ser otimizado sem prejudicar a entrega do conteúdo a longo prazo.

















\section{Métricas e Ferramentas de Análise de Desempenho}
\label{sec:metricas-e-ferramentas}
A avaliação de desempenho em aplicações web modernas é um pilar fundamental para garantir a qualidade da experiência do usuário e o sucesso de um projeto. A análise vai muito além do simples tempo de carregamento total, abrangendo a percepção de velocidade, a capacidade de resposta a interações e a estabilidade visual da interface. Para quantificar esses aspectos de forma padronizada e acionável, o ecossistema de desenvolvimento web dispõe de um conjunto robusto de métricas e ferramentas, que foram essenciais para a coleta de dados e a análise comparativa deste trabalho.

\subsection{Ferramentas de Análise de Mercado}
\label{subsec:ferramentas-analise}
Existem diversas ferramentas consolidadas para a análise de performance web. Soluções como o PageSpeed Insights, GTmetrix e WebPageTest oferecem diagnósticos detalhados sobre a velocidade de carregamento e a experiência do usuário, simulando diferentes condições de rede, dispositivos e localizações geográficas \cite{webabsoluta_ferramentas}. Enquanto o PageSpeed Insights se destaca por integrar dados de campo (do Chrome User Experience Report) e de laboratório, o GTmetrix é conhecido por seus relatórios detalhados com gráficos em cascata (\textit{waterfall charts}) que ajudam a identificar gargalos no carregamento de recursos \cite{gtmetrix_vitals}. O WebPageTest, por sua vez, oferece uma flexibilidade granular nos testes. Para este trabalho, a análise foi centrada em duas iniciativas principais do Google: o Lighthouse e, principalmente, os Core Web Vitals.

\subsection{Google Lighthouse}
\label{subsec:google-lighthouse}
O Google Lighthouse é uma ferramenta de auditoria automatizada e de código aberto, integrada às ferramentas de desenvolvedor do Google Chrome. Ele é projetado para analisar a qualidade de páginas web em cinco categorias principais: Performance, Acessibilidade, Boas Práticas, SEO e \textit{Progressive Web App} (PWA). Ao final da análise, o Lighthouse gera um relatório com pontuações de 0 a 100 para cada categoria e apresenta um conjunto de oportunidades e diagnósticos acionáveis. No contexto deste estudo, o Lighthouse foi utilizado como uma ferramenta de apoio diagnóstico em ambiente de laboratório, essencial para identificar gargalos de renderização, analisar o tempo de bloqueio da \textit{thread} principal (\textit{Total Blocking Time}) e validar aspectos técnicos de SEO e acessibilidade das aplicações desenvolvidas.

\subsection{Core Web Vitals}
\label{subsec:core-web-vitals}
O pilar da coleta de dados empíricos deste trabalho foi o conjunto de métricas conhecido como Core Web Vitals. Proposto pelo Google, este subconjunto dos Web Vitals foi projetado para medir a experiência do usuário no mundo real (\textit{field data}), focando em três aspectos que impactam diretamente a percepção do usuário: velocidade de carregamento, interatividade e estabilidade visual \cite{osmani2025}. A importância dessas métricas é reforçada pelo fato de serem um fator de ranqueamento nos resultados de busca do Google \cite{google_cwv_search}.

\subsubsection{Principais Métricas do Web Vitals}
As métricas a seguir, que compõem os Core Web Vitals atuais, foram essenciais para a análise comparativa:
\begin{description}
    \item[\acrfull{lcp}] Mede o tempo, em segundos, desde o início do carregamento da página até a renderização do maior elemento de conteúdo (imagem ou bloco de texto) visível na tela. É a principal métrica para a percepção de velocidade de carregamento.
    \item[\acrfull{inp}] Avalia a latência de todas as interações do usuário (cliques, toques e digitação) com a página, medindo a capacidade de resposta geral da aplicação. Um baixo INP indica que a página responde rapidamente às ações do usuário.
    \item[\acrfull{cls}] Quantifica a instabilidade visual da página. Mede a soma de todas as mudanças inesperadas de layout que ocorrem durante o carregamento, garantindo que os elementos não "pulem" na tela e frustrem a interação do usuário.
\end{description}

\subsubsection{Métricas Complementares}
Além dos Core Web Vitals, outras métricas foram observadas para fornecer um diagnóstico mais completo do processo de carregamento:
\begin{description}
    \item[\acrfull{ttfb}] Indica a responsividade do servidor. Mede o tempo entre a requisição de um recurso e o momento em que o primeiro byte da resposta chega ao navegador. É um indicador crucial da saúde do \textit{backend}.
    \item[\acrfull{fcp}] Marca o tempo em que o primeiro conteúdo do \acrshort{dom} (texto, imagem, etc.) é renderizado na tela, dando ao usuário o primeiro feedback visual de que a página está carregando.
    \item[\acrfull{ttfb}] Medido em ambiente de laboratório (via Lighthouse), soma o tempo em que a \textit{thread} principal ficou bloqueada por tarefas longas, impedindo a resposta a interações do usuário. É um bom proxy para a métrica de campo INP.
\end{description}
O domínio e a correta interpretação dessas métricas foram fundamentais para a análise comparativa entre as arquiteturas CSR e SSR, permitindo uma compreensão aprofundada do desempenho percebido pelo usuário e servindo como base para as conclusões técnicas apresentadas neste estudo.

\section{Frameworks Web}
\label{sec:frameworks-web}

O uso de bibliotecas e frameworks no desenvolvimento web moderno proporciona ganhos significativos de produtividade, desempenho e organização de código. Eles abstraem operações complexas e oferecem estruturas padronizadas para construção de aplicações escaláveis. A escolha da ferramenta está diretamente relacionada à abordagem de renderização adotada, seja no lado do cliente (\acrshort{csr}) ou do servidor (\acrshort{ssr}).

\subsection{Bibliotecas JavaScript}
\label{subsec:bibliotecas-js}

Bibliotecas JavaScript são conjuntos de funcionalidades reutilizáveis que fornecem recursos específicos para o desenvolvimento de aplicações web. Elas diferem dos frameworks por não imporem uma estrutura rígida, oferecendo maior flexibilidade ao desenvolvedor. A seguir, são apresentadas algumas das bibliotecas mais relevantes no contexto de renderização do lado do cliente (\acrshort{csr}):


\begin{itemize}
  \item React: Desenvolvida pelo Facebook, React é uma biblioteca declarativa focada na construção de interfaces de usuário por meio de componentes reutilizáveis. Seu uso do \textit{virtual DOM} permite renderizações mais eficientes, tornando-a ideal para aplicações interativas com alto desempenho. Apesar de ser comumente chamada de framework, React atua apenas na camada de visualização, exigindo bibliotecas complementares para roteamento e gerenciamento de estado~\cite{react2025}.

  \item jQuery: Uma das bibliotecas mais populares da era inicial do JavaScript moderno, jQuery simplifica tarefas comuns como manipulação do DOM, tratamento de eventos e requisições AJAX. Embora sua popularidade tenha diminuído com o surgimento de bibliotecas mais modernas e frameworks reativos, ela ainda é amplamente utilizada em sistemas legados e aplicações de menor complexidade~\cite{jquery2023}.

  \item Alpine.js: Alpine.js é uma biblioteca leve e reativa voltada para a manipulação de componentes diretamente no HTML, com uma sintaxe declarativa inspirada em Vue.js. Ela é particularmente útil para adicionar interatividade a páginas estáticas ou aplicações simples, sendo uma alternativa eficiente em cenários onde o uso de bibliotecas maiores seria excessivo~\cite{alpinejs2023}.
\end{itemize}

\subsection{Frameworks para CSR}
\label{subsec:frameworks-csr}

No modelo \acrshort{csr}, a renderização da interface é realizada diretamente no navegador do usuário, após o carregamento dos arquivos JavaScript. Frameworks como os listados a seguir são amplamente utilizados para implementar essa abordagem:

\begin{itemize}
    \item Vue.js: framework progressivo para construção de interfaces web interativas. Seu foco está na camada de visualização, com curva de aprendizado acessível e estrutura modular~\cite{vue2025}.
    
    \item Angular: framework completo mantido pelo Google, baseado em TypeScript, que oferece arquitetura robusta e recursos integrados como injeção de dependência e roteamento~\cite{angular2025}.
    
    \item Svelte: framework que realiza a compilação dos componentes no momento do build, eliminando a necessidade de um \textit{virtual DOM}, o que reduz o tempo de carregamento e o uso de recursos do navegador~\cite{svelte2025}.
\end{itemize}

Esses frameworks tornam o desenvolvimento com \acrshort{csr} mais eficiente e sustentável, proporcionando experiências ricas ao usuário com foco em interatividade e responsividade.

\subsection{Meta-frameworks para SSR}
\label{subsec:frameworks-ssr}

Para aplicações com foco em renderização no lado do servidor, os \emph{meta-frameworks} oferecem soluções completas, otimizando tanto o desempenho inicial quanto a indexabilidade em mecanismos de busca. Eles operam sobre frameworks tradicionais (como Vue ou Svelte) ou bibliotecas (como React), incorporando funcionalidades essenciais como roteamento, pré-renderização, recuperação de dados e \textit{hydration}.

\begin{itemize}
    \item Next.js: baseado em React, fornece recursos para \acrshort{ssr}, geração de sites estáticos e suporte a APIs integradas \cite{nextjs2024}.
    
    \item Nuxt.js: extensão do Vue.js que oferece SSR, geração estática e arquitetura modular \cite{nuxtjs2024}.
    
    \item SvelteKit: baseado em Svelte, permite renderização no servidor e no cliente, com foco em simplicidade e desempenho \cite{sveltekit2024}.
    
    \item Angular Universal: solução oficial para SSR em Angular, melhora a indexação e o tempo de carregamento inicial \cite{angularuniversal2024}.
    
    \item Remix: framework full-stack para React que adota um modelo de dados centrado em carregadores e ações \cite{remix2024}.
    
    \item Astro: framework moderno que carrega apenas o JavaScript necessário, permitindo uso híbrido de componentes React, Vue, Svelte e outros \cite{astro2024}.
    
    \item Qwik: introduz o conceito de aplicações \textit{resumíveis}, com SSR e carregamento progressivo de interatividade \cite{qwik2024}.
\end{itemize}

Esses meta-frameworks são especialmente indicados para aplicações que priorizam SEO, acessibilidade e desempenho no primeiro carregamento, como páginas institucionais, lojas virtuais e blogs.

\subsection{Comparativo entre Frameworks CSR e SSR}
\label{subsec:comparativo-frameworks}

A escolha entre frameworks focados em \acrshort{csr} e meta-frameworks que implementam \acrshort{ssr} é uma decisão arquitetônica fundamental, com implicações diretas na performance, na experiência do usuário, no \acrshort{seo} e na complexidade da infraestrutura. Enquanto frameworks como Vue.js, Angular e Svelte (em sua forma pura) se destacam na criação de interfaces ricas e dinâmicas no cliente, os meta-frameworks como Next.js, Nuxt.js e SvelteKit foram projetados para otimizar o carregamento inicial e a indexabilidade por meio da renderização no servidor.

O quadro a seguir sintetiza os principais pontos de contraste entre essas duas abordagens, destacando seus respectivos pontos fortes e casos de uso ideais, de modo a orientar a seleção da ferramenta mais adequada para os requisitos de cada projeto.

\begin{table}[H]
\centering
\caption{Comparação entre frameworks para CSR e SSR}
\label{tab:comparativo-frameworks}
\begin{tabular}{|p{3cm}|p{5.5cm}|p{5.5cm}|}
\hline
Critério & Frameworks CSR (Vue, Angular, Svelte) & Meta-frameworks SSR (Next.js, Nuxt, SvelteKit, etc.) \\
\hline
Renderização Inicial & O conteúdo é montado no navegador após o carregamento do JavaScript & O conteúdo é gerado no servidor e entregue já renderizado ao navegador \\
\hline
Tempo de Carregamento & Maior tempo de carregamento inicial (dependente do JS) & Melhor desempenho no carregamento inicial (TTFB menor) \\
\hline
SEO & Pode ser limitado, pois bots podem não processar JavaScript adequadamente & Excelente, já que o HTML completo está disponível para rastreadores \\
\hline
Interatividade & Alta, com foco em aplicações ricas e dinâmicas & Boa, com necessidade de \textit{hydration} após o carregamento \\
\hline
Complexidade de Infraestrutura & Menor, geralmente servido por CDNs e arquivos estáticos & Maior, exige servidores para processar cada requisição \\
\hline
Casos de Uso Ideais & SPAs, dashboards, aplicações com muitas interações em tempo real & Landing pages, blogs, e-commerces, sites que dependem de SEO \\
\hline
\end{tabular}
\end{table}


\section{Experiência do Usuário}
\label{sec:ux}
A \acrfull{ux} é um aspecto crítico no desenvolvimento de aplicações web, influenciando diretamente a satisfação e a eficácia da interação do usuário com o sistema \cite{atori2023}. Para alcançar uma \acrshort{ux} satisfatória, a escolha entre \acrshort{csr} e \acrshort{ssr} deve considerar fatores como: {\acrshort{seo}}, velocidade de carregamento, interatividade e acessibilidade.
Conforme \citeonline{atori2024}, a \acrshort{ux} vai além da interface gráfica, englobando toda a jornada do usuário desde a navegação até a conclusão de tarefas. 

\subsection{\english{Search Engine Optimization} (SEO)}
\label{sec:seo}

O \acrfull{seo} consiste em um conjunto integrado de práticas de otimização, tanto no aspecto técnico quanto no de conteúdo, com três objetivos principais: maximizar a visibilidade orgânica nos mecanismos de busca, posicionar estrategicamente páginas-chave e garantir uma experiência de usuário qualificada durante o processo de busca. Essas práticas são essenciais para garantir que o conteúdo de um site seja facilmente encontrado e indexado pelos motores de busca, aumentando a probabilidade de atrair visitantes qualificados. Entre os fatores mais conhecidos, destaca-se a velocidade de carregamento da página, que impacta diretamente a experiência do usuário e a classificação nos resultados de busca \cite{conor2022}.
\begin{figure}[H]
    \centering
    \caption{Tempo de Rastreamento e Posicionamento da Página}
    \includegraphics[width=0.6\textwidth]{media/rank_crawl_and_page_rank.png}
    \legend{Fonte: \cite{webPerformance}(adaptado)}
    \label{fig:rank_crawl_and_page_rank}
\end{figure}

A \autoref{fig:rank_crawl_and_page_rank} ilustra a relação entre o tempo de rastreamento e o posicionamento da página. O tempo de rastreamento refere-se ao tempo que os mecanismos de busca levam para acessar e indexar uma página. Quanto mais rápido o tempo de rastreamento, maior a probabilidade de a página ser indexada rapidamente e, consequentemente, melhor seu posicionamento nos resultados de busca. Isso destaca a importância de otimizar o desempenho do site para garantir uma boa classificação nos motores de busca.

\subsection{\english{Velocidade de carregamento}}
\label{sec:velocidade da página}

A velocidade de carregamento de uma página refere-se ao tempo necessário para que todo o seu conteúdo esteja visível e interativo no navegador, desde a solicitação inicial do usuário. Esse tempo pode ser influenciado por diversos fatores, como o tamanho dos arquivos, a complexidade do conteúdo, a qualidade da conexão com a internet e o desempenho do servidor \cite{shopify2024}.

Esse fator é determinante tanto para a \acrshort{ux} quanto para o \acrshort{seo}. Páginas que carregam rapidamente tendem a apresentar menores taxas de rejeição e melhores resultados em métricas de conversão. Além disso, o \acrshort{seo} utiliza a velocidade de carregamento como um dos critérios de ranqueamento nos mecanismos de busca \cite{conor2022}.

De acordo com \citeonline{google}, quanto mais rápido um site carregar, melhor tende a ser a experiência do usuário. Sites lentos comprometem a navegação e reduzem o tempo de permanência, afetando negativamente o engajamento.

A percepção de desempenho muitas vezes chamada de \emph{velocidade percebida} também é um fator crucial para a usabilidade e pode ser tão relevante quanto o tempo de carregamento real. Nesse sentido, a escolha entre \acrshort{ssr} e \acrshort{csr} influencia diretamente essa percepção. O \acrshort{ssr} geralmente proporciona carregamento inicial mais rápido, pois o conteúdo é renderizado no servidor e entregue ao navegador já pronto para exibição. Isso permite que os usuários visualizem o conteúdo principal imediatamente, mesmo que outros recursos ainda estejam sendo carregados \cite{atori2024}.

Por outro lado, no \acrshort{csr}, o navegador precisa baixar, interpretar e executar o JavaScript antes de renderizar qualquer conteúdo. Isso pode resultar em uma exibição inicial em branco ou em telas de carregamento, o que compromete a percepção de desempenho especialmente em conexões lentas ou dispositivos com menor capacidade de processamento \cite{pixelfree2023}.


\subsection{Interatividade}
\label{subsec:interatividade}

A interatividade é um fator decisivo na experiência do usuário em aplicações web modernas, pois determina a forma como os usuários percebem a continuidade e a capacidade de resposta durante a navegação. Nas aplicações que utilizam \acrshort{csr}, o código JavaScript é executado diretamente no navegador, permitindo respostas imediatas a interações como cliques, preenchimento de formulários ou navegação entre páginas internas. Essa abordagem possibilita transições de página mais suaves e experiências semelhantes às de aplicativos nativos, sem a necessidade de recarregamentos completos \cite{pixelfree2023}.

Segundo \citeonline{atori2024}, a renderização no lado do cliente favorece experiências altamente dinâmicas, oferecendo um nível elevado de controle sobre os elementos da interface. Em contrapartida, o \acrshort{ssr}, embora proporcione carregamento inicial mais rápido e visibilidade imediata do conteúdo, apresenta limitações em termos de interatividade. Alterações na interface em aplicações \acrshort{ssr} geralmente demandam comunicações adicionais com o servidor, o que pode comprometer a continuidade da experiência do usuário \cite{atori2024, splunk2023}.

Para mitigar essas limitações, abordagens híbridas têm sido amplamente adotadas. Nelas, o conteúdo é inicialmente renderizado no servidor e, posteriormente, reativado no cliente com JavaScript, em uma estratégia conhecida como \emph{hydration} \cite{splunk2023}. Essa técnica busca aliar os benefícios de desempenho e \acrshort{seo} do \acrshort{ssr} com a interatividade aprimorada do \acrshort{csr}.


\subsection{Acessibilidade}
\label{subsec:acessibilidade}

A acessibilidade em aplicações web refere-se à capacidade de tornar conteúdos e funcionalidades utilizáveis por pessoas com deficiência, como visual, auditiva, motora ou cognitiva. É um princípio essencial para garantir a equidade no acesso à informação e à interação digital. De acordo com \cite{pixelfree2023access}, acessibilidade diz respeito a assegurar que todos, independentemente de suas habilidades, possam acessar e interagir com o conteúdo da web. Para pessoas com deficiência, isso pode significar o uso de leitores de tela, navegação por teclado ou a dependência de outras tecnologias assistivas.

As abordagens de renderização, como \acrshort{csr} e \acrshort{ssr}, impactam diretamente a acessibilidade, especialmente na compatibilidade com essas tecnologias. Em aplicações que utilizam \acrshort{csr}, o conteúdo geralmente é carregado de forma assíncrona após a execução do JavaScript, o que pode dificultar a leitura imediata por leitores de tela que dependem de uma estrutura HTML previamente carregada para interpretar a página corretamente \cite{pixelfree2023access}. Já no \acrshort{ssr}, o conteúdo é entregue completamente no carregamento inicial, facilitando a interpretação por essas ferramentas e proporcionando uma experiência mais estável para usuários com deficiência visual \cite{atori2024}.

Além disso, em contextos com atualizações dinâmicas de conteúdo como ocorre em SPAs com \acrshort{csr} é necessário adotar práticas específicas para garantir a acessibilidade, como gerenciamento de foco, uso de alertas ARIA e atualização de leitores de tela após mudanças no DOM. Essas medidas são fundamentais para que as mudanças de visualização sejam percebidas corretamente por tecnologias assistivas, uma vez que alterações no DOM nem sempre são reconhecidas automaticamente por leitores de tela. O envio de foco a elementos interativos ou o uso de regiões ARIA ao vivo são técnicas recomendadas para anunciar mudanças de estado ao usuário \cite{sutton2018}.

Assim, embora o \acrshort{ssr} ofereça uma base naturalmente mais acessível, ambas as abordagens podem ser igualmente inclusivas quando aplicadas com atenção às diretrizes e boas práticas de acessibilidade.



\section{Ferramentas Modernas para Prototipação e Interfaces}
\label{sec:ferramentas-modernas}

Nesta seção são apresentadas duas ferramentas inovadoras utilizadas para acelerar o desenvolvimento frontend: a plataforma v0 e a biblioteca de componentes shadcn/ui. Ambas representam abordagens modernas para construção de interfaces dinâmicas, acessíveis e escaláveis.

\subsection{v0}
\label{subsec:v0}

A v0 é uma plataforma assistida por Inteligência Artificial projetada para transformar descrições em linguagem natural em aplicações web funcionais. A partir de prompts descritivos, a ferramenta gera código utilizando tecnologias modernas como React, Next.js e Tailwind CSS, permitindo prototipação rápida e iteração sobre interfaces \cite{v0_docs}. O fluxo básico inclui: escrever a ideia em texto, gerar a interface automaticamente, revisar e ajustar os elementos e exportar o código para integração no projeto.

\subsection{shadcn/ui}
\label{subsec:shadcn}

O shadcn/ui é uma biblioteca de componentes open source baseada em Radix UI e estilizada com Tailwind CSS. Ao contrário de bibliotecas tradicionais, os componentes do shadcn/ui são copiados diretamente para o projeto, oferecendo ao desenvolvedor total controle sobre o código e possibilitando personalizações profundas \cite{shadcn_docs}. Essa abordagem favorece flexibilidade e consistência visual no desenvolvimento de aplicações modernas.

\subsection{Integração entre v0 e shadcn/ui}
\label{subsec:integracao-v0-shadcn}

A integração entre v0 e shadcn/ui proporciona uma experiência otimizada para geração de interfaces. Ao utilizar a plataforma v0, os componentes gerados são construídos com base na arquitetura do shadcn/ui, incluindo as práticas recomendadas de acessibilidade e estilização com Tailwind CSS \cite{v0_docs, shadcn_docs}. Essa integração permite que desenvolvedores iniciem com protótipos gerados automaticamente e, em seguida, façam ajustes diretamente no código dos componentes, mantendo um alto grau de personalização e performance. Além disso, ela favorece o uso de estratégias modernas como \acrshort{ssr} e \acrshort{csr}, oferecendo compatibilidade com frameworks como Next.js e Vite.




\section{Processo de Desenvolvimento e Controle de Gestão de Software}
\label{sec:git-github}

O desenvolvimento de aplicações web modernas exige práticas que garantam organização, rastreabilidade e colaboração eficiente entre desenvolvedores. Nesse contexto, ferramentas de controle de versão como o Git e plataformas de hospedagem como o GitHub são fundamentais para o gerenciamento do ciclo de vida do software \cite{github_official}.

\subsection{Git}
\label{subsec:git}

O Git é um sistema de controle de versão distribuído criado por Linus Torvalds em 2005 com o objetivo de gerenciar projetos de forma rápida e eficiente, independentemente do tamanho ou complexidade \cite{chacon_git}. Ele permite que múltiplos desenvolvedores trabalhem simultaneamente em um projeto, mantendo o histórico de alterações de forma segura e auditável.

Entre os conceitos fundamentais do Git, destacam-se:

\begin{itemize}
\item Repositório (\textit{Repository}): Estrutura que armazena o histórico completo do projeto, incluindo arquivos, diretórios e suas versões ao longo do tempo.
\item Commits: Registros de alterações no projeto. Cada commit possui um identificador único (hash) e uma mensagem descritiva \cite{chacon_git}.
\item Branches: Ramificações independentes do repositório que permitem o desenvolvimento paralelo de funcionalidades, correções ou experimentos sem impactar o código principal.
\item Merge: Integração de alterações realizadas em diferentes branches.
\item Clone e Pull: Operações que permitem obter uma cópia local do repositório e sincronizar com atualizações remotas.
\end{itemize}

O modelo distribuído do Git permite que cada colaborador mantenha uma cópia completa do repositório em sua máquina local, o que garante maior resiliência e independência em relação ao servidor central \cite{chacon_git}.

\subsection{GitHub}
\label{subsec:github}

O GitHub é uma plataforma de hospedagem de código baseada em Git, que amplia suas funcionalidades com recursos colaborativos e integração contínua \cite{github_official}. Fundada em 2008, a plataforma popularizou-se como um ambiente de colaboração para projetos de software de código aberto e privado.

Além de hospedar repositórios Git, o GitHub oferece funcionalidades como:
\begin{itemize}
\item Issues: Ferramenta para rastreamento de tarefas, bugs e melhorias \cite{github_official}.
\item Pull Requests (PR): Fluxo de revisão e integração de código, permitindo que contribuições sejam analisadas antes de serem incorporadas ao branch principal.
\item Actions: Automatização de processos com integração contínua (CI) e entrega contínua (CD).
\item Wikis e Documentação: Área para criação de páginas informativas sobre o projeto.
\end{itemize}

\subsection{GitHub Projects}
\label{subsec:github-projects}

O GitHub Projects é uma funcionalidade integrada à plataforma que possibilita o gerenciamento de projetos utilizando quadros visuais baseados em metodologias ágeis, como Kanban e Scrum \cite{github_projects}. Essa ferramenta permite organizar tarefas, acompanhar o progresso e priorizar demandas de maneira colaborativa.

Entre os recursos oferecidos pelo GitHub Projects, destacam-se:

\begin{itemize}
\item Quadros Kanban: Visualização de tarefas em colunas (como \textit{To Do}, \textit{In Progress} e \textit{Done}), facilitando o acompanhamento do fluxo de trabalho.
\item Automação: Regras automáticas que movem cartões entre colunas com base em eventos, como o fechamento de issues ou merge de pull requests \cite{github_projects}.
\item Customização: Campos personalizados e filtros para adaptar o quadro às necessidades do projeto.
\item Integração com Issues e Pull Requests: Possibilidade de vincular tarefas diretamente ao código, permitindo rastreabilidade completa entre planejamento e implementação.
\end{itemize}






\section{News API}
\label{sec:news-api}

A News API é uma interface de programação que disponibiliza fluxos de notícias e artigos de forma estruturada, permitindo o acesso a conteúdos de mais de 150\,000 fontes jornalísticas ao redor do mundo. Seu propósito é fornecer informações publicadas em tempo real, facilitando o desenvolvimento de soluções de agregação, análise e visualização de notícias \cite{newsapi_docs}.

\subsection{Escopo e cobertura}
A plataforma oferece dois principais tipos de consulta: 

\begin{itemize}
    \item Busca por artigos (\texttt{/everything}): permite pesquisar notícias com base em termos, operadores booleanos, intervalos de datas, domínios específicos e critérios de ordenação, como relevância, popularidade ou data de publicação \cite{newsapi_docs}.
    \item Manchetes principais (\texttt{/top-headlines}): retorna as notícias mais recentes, com filtros por país, categoria jornalística e fontes específicas.
\end{itemize}

Além disso, a News API disponibiliza o endpoint \texttt{/sources}, que fornece metadados sobre os veículos indexados, como nome, idioma, categoria e URL oficial.

\subsection{Autenticação e formato de resposta}
Para utilizar os endpoints, é necessário um \acrshort{api} key, que autentica as requisições e controla o uso da plataforma. As respostas são retornadas no formato \acrshort{json}, contendo campos como \texttt{status}, \texttt{totalResults} e uma lista de objetos \texttt{articles}, com atributos como título, autor, descrição, \acrshort{url} e data de publicação \cite{newsapi_docs}.

\subsection{Funcionalidade e integração}
A News API suporta buscas avançadas com:

\begin{itemize}
    \item termos exatos ou operadores lógicos (\texttt{AND}, \texttt{OR}, \texttt{NOT});
    \item filtros por idioma, domínios específicos e intervalos de datas (\texttt{from}, \texttt{to});
    \item paginação e controle de volume de resultados, com limite máximo de 100 artigos por página.
\end{itemize}

Essas características permitem integração tanto em aplicações com \acrshort{csr}, que realizam chamadas diretamente do navegador após o carregamento, quanto em soluções com \acrshort{ssr}, onde as requisições são feitas na camada servidor, possibilitando que o conteúdo seja renderizado previamente antes de ser entregue ao cliente.






\section{Infraestrutura de Contêineres e Docker}
\label{cap:docker}

Este capítulo apresenta os conceitos fundamentais de contêineres e da plataforma Docker, abordando sua arquitetura, seus principais objetos e o processo de construção de imagens com o Dockerfile. Adicionalmente, são discutidas boas práticas de otimização e a integração dessa tecnologia com o estudo comparativo entre \acrshort{csr} e \acrshort{ssr}. \cite{docker_overview,dockerfile_ref}

\subsection{Fundamentos da Plataforma Docker}
\label{sec:docker-fundamentos}

O Docker é uma plataforma de código aberto que viabiliza o desenvolvimento, a distribuição e a execução de aplicações em ambientes isolados denominados contêineres. Esses contêineres são leves, portáteis e auto-suficientes, pois empacotam a aplicação com todas as suas dependências, bibliotecas e configurações. Essa abordagem padroniza os ambientes de execução, reduzindo inconsistências entre as máquinas de desenvolvimento, teste e produção, e acelera os ciclos de integração e entrega contínua (\acrshort{ci}/\acrshort{cd}) \cite{docker_overview}.

A arquitetura do Docker segue o modelo cliente-servidor, onde o cliente (\texttt{docker CLI}) envia comandos para o serviço (daemon \texttt{dockerd}), que gerencia a construção, execução e distribuição dos objetos Docker. A comunicação ocorre por meio de uma \acrshort{api} REST, via \textit{Unix sockets} ou interface de rede. Para facilitar a distribuição, as imagens são armazenadas em \textit{registries}, como o Docker Hub (público) ou registros privados, permitindo a portabilidade entre ambientes locais, datacenters e nuvens \cite{docker_overview}.

\begin{figure}[H]
  \centering
  \caption{Arquitetura simplificada do Docker (cliente, daemon, registries e objetos).}
  \includegraphics[width=0.8\textwidth]{media/docker_architecture.png}
  \legend{Fonte: Adaptado da documentação oficial do Docker \cite{docker_overview}.}
  \label{fig:docker-arquitetura}
\end{figure}

Os principais objetos manipulados pela plataforma são as imagens e os contêineres. Uma imagem é um modelo (\textit{template}) imutável, composto por um sistema de arquivos em camadas (\textit{layers}), onde cada camada representa uma instrução do processo de construção. Um contêiner, por sua vez, é uma instância executável e isolada de uma imagem. Ele pode ser criado, iniciado, parado e removido, e suas alterações internas são, por padrão, efêmeras, sendo descartadas ao final de seu ciclo de vida, a menos que se utilizem volumes para persistência de dados \cite{docker_overview}.

\subsection{Construção de Imagens com Dockerfile}
\label{sec:dockerfile-construcao}

A construção de imagens é definida por meio de um Dockerfile, um arquivo de texto com um conjunto de instruções sequenciais. Cada instrução gera uma nova camada na imagem, otimizando reconstruções futuras por meio de cache. As instruções essenciais incluem \texttt{FROM} para definir a imagem base; \texttt{RUN} para executar comandos de instalação ou compilação; \texttt{COPY} para adicionar arquivos do contexto local; e \texttt{CMD} ou \texttt{ENTRYPOINT} para especificar o comando de execução padrão do contêiner. Outras instruções como \texttt{WORKDIR}, \texttt{ENV} e \texttt{EXPOSE} configuram o ambiente de execução \cite{dockerfile_ref}. Para otimizar o processo, o arquivo \texttt{.dockerignore} é utilizado para excluir arquivos e diretórios desnecessários do contexto de build, reduzindo o tamanho da imagem e o tempo de construção.

\subsection{Boas Práticas e Otimização de Builds}
\label{sec:docker-boas-praticas}

Para criar imagens eficientes, seguras e enxutas, é fundamental adotar boas práticas. A principal delas é o uso de multi-stage builds, uma técnica que permite utilizar múltiplos estágios \texttt{FROM} em um mesmo Dockerfile. Com isso, é possível compilar a aplicação em um estágio com todas as ferramentas de desenvolvimento (\textit{toolchain}) e copiar apenas os artefatos finais para um estágio de produção mínimo, baseado em uma imagem enxuta como a \texttt{alpine} ou \texttt{scratch}. O resultado é uma imagem final drasticamente menor, com superfície de ataque reduzida e mais rápida para distribuir \cite{dockerfile_ref}.

\begin{codigo}[H]
\begin{lstlisting}[language=Dockerfile]
# syntax=docker/dockerfile:1
# Estágio de build
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
RUN npm run build

# Estágio de produção (runtime)
FROM node:20-alpine AS runtime
WORKDIR /app
ENV NODE_ENV=production
COPY --from=build /app/.next ./.next
COPY --from=build /app/package*.json ./
EXPOSE 3000
CMD ["node", ".next/standalone/server.js"]
\end{lstlisting}
\caption{Exemplo de multi-stage build para aplicação SSR com Node/Next.js}
\label{lst:dockerfile-multistage}
\end{codigo}

A otimização do cache de build também é crucial. Como cada instrução gera uma camada, a ordem no Dockerfile deve ser da menos para a mais volátil, permitindo que o cache seja aproveitado ao máximo. Para operações que frequentemente mudam, como a instalação de pacotes, o motor de build moderno (BuildKit) oferece montagens de cache avançadas, como \texttt{RUN --mount=type=cache}, que persistem o cache de gerenciadores de pacotes sem invalidar as camadas da imagem. Além disso, a segurança deve ser uma prioridade: dados sensíveis, como tokens e chaves SSH, nunca devem ser inseridos na imagem via \texttt{ENV} ou \texttt{ARG}. A abordagem correta é utilizar montagens de segredos, como \texttt{RUN --mount=type=secret}, que disponibilizam as credenciais apenas durante o build, sem armazená-las nas camadas finais \cite{dockerfile_ref}.

\subsection{Padrões de Infraestrutura para Aplicações CSR e SSR}
\label{sec:docker-padroes-infra}

A operacionalização de aplicações containerizadas segue um ciclo de vida bem definido, que envolve as etapas de construir a imagem (\texttt{docker build}), publicá-la em um registry (\texttt{docker push}) e executá-la (\texttt{docker run}). Nessa última etapa, são configurados aspectos da infraestrutura como mapeamento de portas, volumes para dados persistentes e conexões de rede. A forma como essa infraestrutura é configurada varia significativamente conforme a arquitetura de renderização.

No contexto deste estudo, dois padrões de infraestrutura se destacam. Para aplicações \acrshort{csr} ou \acrshort{ssg}, que resultam em um conjunto de arquivos estáticos (HTML, CSS, JS), o padrão é utilizar um servidor web leve e de alta performance, como o Nginx, cuja única responsabilidade é servir esses arquivos eficientemente.

\begin{codigo}[H]
\begin{lstlisting}[language=Dockerfile]
# Padrão de infraestrutura para aplicação CSR: servir arquivos estáticos com Nginx
FROM nginx:1.27-alpine
COPY ./dist/ /usr/share/nginx/html
# (Opcional) Copiar nginx.conf customizado para rotas, etc.
# COPY ./nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
\end{lstlisting}
\caption{Servidor estático com Nginx para aplicação CSR/SSG}
\label{lst:dockerfile-nginx-static}
\end{codigo}

Por outro lado, para aplicações \acrshort{ssr}, a infraestrutura requer um ambiente de execução de servidor, como o Node.js, para processar as requisições e renderizar as páginas dinamicamente. A containerização, nesse caso, garante que todo o ambiente e suas dependências estejam empacotados e prontos para execução. Conforme apresentado neste capítulo, o Docker fornece uma base consistente para essa tarefa, com isolamento leve, portabilidade e um ciclo de vida claro (construir, distribuir, executar). O Dockerfile, aliado a boas práticas como \textit{multi-stage builds} e otimização de cache, viabiliza imagens menores, builds mais rápidos e maior segurança \cite{docker_overview,dockerfile_ref}. A aplicação desses recursos é o que permite que ambas as arquiteturas (CSR e SSR) sejam avaliadas em ambientes padronizados e isolados, eliminando variáveis de infraestrutura. Em síntese, o Docker fornece a base metodológica consistente e reprodutível necessária para validar as conclusões deste estudo, focando a análise puramente nas diferenças de performance entre as estratégias de renderização.